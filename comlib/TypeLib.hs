-- Automatically generated by HaskellDirect (ihc.exe), version 0.20
-- Created: 20:13 Pacific Standard Time, Tuesday 16 December, 2003
-- Command line: -fno-qualified-names -fno-export-list -fappend-interface-short-name -fno-overload-variant --gen-headers -c TypeLib.idl -o TypeLib.hs

module TypeLib where

import Prelude
import Automation (VARIANT, copyVARIANT, unmarshallVARIANT, 
                   writeVARIANT, sizeofVARIANT, readVARIANT, marshallVARIANT, 
                   allocVARIANT)
import Bits ((.&.))
import Com (GUID, writeGUID, readGUID, freeBSTR, writeBSTR, 
            readBSTR, IUnknown, writeIUnknown, readIUnknown, IID, mkIID, 
            marshallGUID, invokeAndCheck, marshallIUnknown, marshallBSTR, 
            marshallIID, invokeIt)
import Foreign.ForeignPtr (withForeignPtr)
import Foreign.Ptr (Ptr, castPtr)
import HDirect (writeWord32, writeInt32, addNCastPtr, readWord32, 
                readInt32, marshallUnion, unmarshallUnion, allocBytes, 
                writeunique, readunique, writeWord16, readWord16, free, writelist, 
                unmarshallWord16, unmarshalllist, trivialFree, writeEnum32, 
                readEnum32, derefPtr, marshalllist, sizeofInt32, writePtr, 
                readPtr, unmarshallWord32, Flags(..), pow2Series, orList, 
                writeInt16, readInt16, unmarshallInt16, writeMaybe, readMaybe, 
                sizeofWord32, doThenFree, marshallref, sizeofPtr, marshallEnum32, 
                sizeofForeignPtr, freeref, sizeofWord16)
import Int (Int32, Int16)
import Maybe (mapMaybe)
import StdTypes (LONG, ULONG, DWORD, VARTYPE, USHORT, WORD, 
                 LPOLESTR, LCID, SCODE, SHORT, PVOID, REFGUID, UINT, INT, BOOL)
import WideString (writeWideString, readWideString, 
                   marshallWideString, freeWideString, WideString, 
                   unmarshallWideString)
import Word (Word32, Word16)

{- BEGIN_C_CODE
#include "StdTypes.h"
END_C_CODE-}
{- BEGIN_C_CODE
typedef void* VARIANT;
END_C_CODE-}
{- BEGIN_C_CODE
typedef void* BSTR;
END_C_CODE-}
{- BEGIN_C_CODE
typedef DWORD HRESULT;
END_C_CODE-}
{- BEGIN_C_CODE
typedef void* IUnknown;
END_C_CODE-}
data SAFEARRAYBOUND = TagSAFEARRAYBOUND {cElements :: ULONG,
                                         lLbound :: LONG}
                        
writeSAFEARRAYBOUND :: Ptr SAFEARRAYBOUND
                    -> SAFEARRAYBOUND
                    -> IO ()
writeSAFEARRAYBOUND ptr (TagSAFEARRAYBOUND cElements lLbound) =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    writeWord32 pf1 cElements
    let pf2 = addNCastPtr pf1 4
    writeInt32 pf2 lLbound

readSAFEARRAYBOUND :: Ptr SAFEARRAYBOUND
                   -> IO SAFEARRAYBOUND
readSAFEARRAYBOUND ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    cElements <- readWord32 pf1
    let pf2 = addNCastPtr pf1 4
    lLbound <- readInt32 pf2
    return (TagSAFEARRAYBOUND cElements lLbound)

sizeofSAFEARRAYBOUND :: Word32
sizeofSAFEARRAYBOUND = 8

type LPSAFEARRAYBOUND = SAFEARRAYBOUND
type DISPID = LONG
type MEMBERID = DISPID
type HREFTYPE = DWORD
data TYPEKIND
 = TKIND_ENUM
 | TKIND_RECORD
 | TKIND_MODULE
 | TKIND_INTERFACE
 | TKIND_DISPATCH
 | TKIND_COCLASS
 | TKIND_ALIAS
 | TKIND_UNION
 | TKIND_MAX
 deriving (Enum)
type IHC_TAG_4 = TYPEDESC
type IHC_TAG_5 = ARRAYDESC
data IHC_TAG_3
 = Lptdesc (Maybe IHC_TAG_4)
 | Lpadesc (Maybe IHC_TAG_5)
 | Hreftype HREFTYPE
 | IHC_TAG_3_Anon
 
marshallIHC_TAG_3 :: IHC_TAG_3
                  -> IO (IHC_TAG_3, Word16)
marshallIHC_TAG_3 = marshallUnion "marshallIHC_TAG_3"

unmarshallIHC_TAG_3 :: IHC_TAG_3
                    -> Word16
                    -> IO IHC_TAG_3
unmarshallIHC_TAG_3 = unmarshallUnion "unmarshallIHC_TAG_3"

writeIHC_TAG_3 :: (Word16 -> IO ())
               -> Ptr IHC_TAG_3
               -> IHC_TAG_3
               -> IO ()
writeIHC_TAG_3 write_tag ptr v =
  case v of
     (Lptdesc lptdesc) -> do
                            write_tag 26
                            writeunique (allocBytes (fromIntegral sizeofTYPEDESC)) writeTYPEDESC (castPtr ptr) lptdesc
     (Lpadesc lpadesc) -> do
                            write_tag 28
                            writeunique (allocBytes (fromIntegral sizeofARRAYDESC)) writeARRAYDESC (castPtr ptr) lpadesc
     (Hreftype hreftype) -> do
                              write_tag 29
                              writeWord32 (castPtr ptr) hreftype
     IHC_TAG_3_Anon -> return ()

readIHC_TAG_3 :: IO Word16
              -> Ptr IHC_TAG_3
              -> IO IHC_TAG_3
readIHC_TAG_3 read_tag ptr =
  do
    tag <- read_tag
    case tag of
       26 -> do
               v <- readunique readTYPEDESC (castPtr ptr)
               return (Lptdesc v)
       27 -> do
               v <- readunique readTYPEDESC (castPtr ptr)
               return (Lptdesc v)
       28 -> do
               v <- readunique readARRAYDESC (castPtr ptr)
               return (Lpadesc v)
       29 -> do
               v <- readWord32 (castPtr ptr)
               return (Hreftype v)
       _ -> return (IHC_TAG_3_Anon)

sizeofIHC_TAG_3 :: Word32
sizeofIHC_TAG_3 = 4

freeIHC_TAG_3 :: Word16
              -> Ptr IHC_TAG_3
              -> IO ()
freeIHC_TAG_3 read_tag ptr =
  do
    tag <- return (read_tag)
    case tag of
       26 -> return ()
       27 -> return ()
       28 -> return ()
       29 -> return ()
       _ -> return ()

type IHC_TAG_2 = IHC_TAG_3
data TYPEDESC = TagTYPEDESC {iHC_TAG_1 :: IHC_TAG_3,
                             vt :: VARTYPE}
                  
writeTYPEDESC :: Ptr TYPEDESC
              -> TYPEDESC
              -> IO ()
writeTYPEDESC ptr (TagTYPEDESC iHC_TAG_1 vt) =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    writeIHC_TAG_3 (writeWord16 (addNCastPtr pf0 4)) pf1 iHC_TAG_1
    let pf2 = addNCastPtr pf1 4
    writeWord16 pf2 vt

readTYPEDESC :: Ptr TYPEDESC
             -> IO TYPEDESC
readTYPEDESC ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    iHC_TAG_1 <- readIHC_TAG_3 (readWord16 (addNCastPtr pf0 4)) pf1
    let pf2 = addNCastPtr pf1 4
    vt <- readWord16 pf2
    return (TagTYPEDESC iHC_TAG_1 vt)

sizeofTYPEDESC :: Word32
sizeofTYPEDESC = 8

data ARRAYDESC = TagARRAYDESC {tdescElem :: TYPEDESC,
                               rgbounds :: [SAFEARRAYBOUND]}
                   
freeARRAYDESC :: Ptr ARRAYDESC
              -> IO ()
freeARRAYDESC ptr =
  let
   struct_ptr__ = addNCastPtr ptr 12
  in
  free struct_ptr__

writeARRAYDESC :: Ptr ARRAYDESC
               -> ARRAYDESC
               -> IO ()
writeARRAYDESC ptr (TagARRAYDESC tdescElem rgbounds) =
  let
   cDims = (fromIntegral (length rgbounds) :: Word16)
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    writeTYPEDESC pf1 tdescElem
    let pf2 = addNCastPtr pf1 8
    writeWord16 pf2 cDims
    let pf3 = addNCastPtr pf2 4
    writelist False sizeofSAFEARRAYBOUND writeSAFEARRAYBOUND pf3 rgbounds

readARRAYDESC :: Ptr ARRAYDESC
              -> IO ARRAYDESC
readARRAYDESC ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    tdescElem <- readTYPEDESC pf1
    let pf2 = addNCastPtr pf1 8
    cDims <- readWord16 pf2
    let pf3 = addNCastPtr pf2 4
    rgbounds <- return pf3
    cDims <- unmarshallWord16 cDims
    rgbounds <- unmarshalllist sizeofSAFEARRAYBOUND 0 ((fromIntegral cDims :: Word32)) readSAFEARRAYBOUND rgbounds
    return (TagARRAYDESC tdescElem rgbounds)

sizeofARRAYDESC :: Word32
sizeofARRAYDESC = 20

type VARIANTARG = VARIANT
data PARAMDESCEX = TagPARAMDESCEX {cBytes :: ULONG,
                                   varDefaultValue :: VARIANT}
                     
freePARAMDESCEX :: Ptr PARAMDESCEX
                -> IO ()
freePARAMDESCEX ptr =
  let
   struct_ptr__ = addNCastPtr ptr 8
  in
  trivialFree struct_ptr__

writePARAMDESCEX :: Ptr PARAMDESCEX
                 -> PARAMDESCEX
                 -> IO ()
writePARAMDESCEX ptr (TagPARAMDESCEX cBytes varDefaultValue) =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    writeWord32 pf1 cBytes
    let pf2 = addNCastPtr pf1 8
    copyVARIANT pf2 varDefaultValue

readPARAMDESCEX :: Ptr PARAMDESCEX
                -> IO PARAMDESCEX
readPARAMDESCEX ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    cBytes <- readWord32 pf1
    let pf2 = addNCastPtr pf1 8
    varDefaultValue <- unmarshallVARIANT pf2
    return (TagPARAMDESCEX cBytes varDefaultValue)

sizeofPARAMDESCEX :: Word32
sizeofPARAMDESCEX = 24

type LPPARAMDESCEX = Maybe PARAMDESCEX
data PARAMDESC = TagPARAMDESC {pparamdescex :: LPPARAMDESCEX,
                               wParamFlags :: USHORT}
                   
freePARAMDESC :: Ptr PARAMDESC
              -> IO ()
freePARAMDESC ptr =
  let
   struct_ptr__ = addNCastPtr ptr 0
  in
  trivialFree struct_ptr__

writePARAMDESC :: Ptr PARAMDESC
               -> PARAMDESC
               -> IO ()
writePARAMDESC ptr (TagPARAMDESC pparamdescex wParamFlags) =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    writeunique (allocBytes (fromIntegral sizeofPARAMDESCEX)) writePARAMDESCEX pf1 pparamdescex
    let pf2 = addNCastPtr pf1 4
    writeWord16 pf2 wParamFlags

readPARAMDESC :: Ptr PARAMDESC
              -> IO PARAMDESC
readPARAMDESC ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    pparamdescex <- readunique readPARAMDESCEX pf1
    let pf2 = addNCastPtr pf1 4
    wParamFlags <- readWord16 pf2
    return (TagPARAMDESC pparamdescex wParamFlags)

sizeofPARAMDESC :: Word32
sizeofPARAMDESC = 8

type LPPARAMDESC = PARAMDESC
pARAMFLAG_NONE :: USHORT
pARAMFLAG_NONE = 0x0

pARAMFLAG_FIN :: USHORT
pARAMFLAG_FIN = 0x1

pARAMFLAG_FOUT :: USHORT
pARAMFLAG_FOUT = 0x2

pARAMFLAG_FLCID :: USHORT
pARAMFLAG_FLCID = 0x4

pARAMFLAG_FRETVAL :: USHORT
pARAMFLAG_FRETVAL = 0x8

pARAMFLAG_FOPT :: USHORT
pARAMFLAG_FOPT = 0x10

pARAMFLAG_FHASDEFAULT :: USHORT
pARAMFLAG_FHASDEFAULT = 0x20

data IDLDESC = TagIDLDESC {dwReserved :: ULONG,
                           wIDLFlags :: USHORT}
                 
writeIDLDESC :: Ptr IDLDESC
             -> IDLDESC
             -> IO ()
writeIDLDESC ptr (TagIDLDESC dwReserved wIDLFlags) =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    writeWord32 pf1 dwReserved
    let pf2 = addNCastPtr pf1 4
    writeWord16 pf2 wIDLFlags

readIDLDESC :: Ptr IDLDESC
            -> IO IDLDESC
readIDLDESC ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    dwReserved <- readWord32 pf1
    let pf2 = addNCastPtr pf1 4
    wIDLFlags <- readWord16 pf2
    return (TagIDLDESC dwReserved wIDLFlags)

sizeofIDLDESC :: Word32
sizeofIDLDESC = 8

type LPIDLDESC = IDLDESC
iDLFLAG_NONE :: USHORT
iDLFLAG_NONE = 0

iDLFLAG_FIN :: USHORT
iDLFLAG_FIN = 1

iDLFLAG_FOUT :: USHORT
iDLFLAG_FOUT = 2

iDLFLAG_FLCID :: USHORT
iDLFLAG_FLCID = 4

iDLFLAG_FRETVAL :: USHORT
iDLFLAG_FRETVAL = 8

{- BEGIN_C_CODE
#if 0
END_C_CODE-}
{- BEGIN_C_CODE
/* the following is what MIDL knows how to remote */
END_C_CODE-}
data ELEMDESC = TagELEMDESC {tdesc :: TYPEDESC,
                             paramdesc :: PARAMDESC}
                  
freeELEMDESC :: Ptr ELEMDESC
             -> IO ()
freeELEMDESC ptr =
  let
   struct_ptr__ = addNCastPtr ptr 8
  in
  freePARAMDESC struct_ptr__

writeELEMDESC :: Ptr ELEMDESC
              -> ELEMDESC
              -> IO ()
writeELEMDESC ptr (TagELEMDESC tdesc paramdesc) =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    writeTYPEDESC pf1 tdesc
    let pf2 = addNCastPtr pf1 8
    writePARAMDESC pf2 paramdesc

readELEMDESC :: Ptr ELEMDESC
             -> IO ELEMDESC
readELEMDESC ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    tdesc <- readTYPEDESC pf1
    let pf2 = addNCastPtr pf1 8
    paramdesc <- readPARAMDESC pf2
    return (TagELEMDESC tdesc paramdesc)

sizeofELEMDESC :: Word32
sizeofELEMDESC = 16

{- BEGIN_C_CODE
#else /* 0 */
END_C_CODE-}
{- BEGIN_C_CODE
typedef struct tagELEMDESC {
END_C_CODE-}
{- BEGIN_C_CODE
    TYPEDESC tdesc;             /* the type of the element */
END_C_CODE-}
{- BEGIN_C_CODE
    union {
END_C_CODE-}
{- BEGIN_C_CODE
        IDLDESC idldesc;        /* info for remoting the element */
END_C_CODE-}
{- BEGIN_C_CODE
        PARAMDESC paramdesc;    /* info about the parameter */
END_C_CODE-}
{- BEGIN_C_CODE
    };
END_C_CODE-}
{- BEGIN_C_CODE
} ELEMDESC, * LPELEMDESC;
END_C_CODE-}
{- BEGIN_C_CODE
#endif /* 0 */
END_C_CODE-}
data TYPEATTR = TagTYPEATTR {guid :: GUID,
                             lcid :: LCID,
                             dwReserved0 :: DWORD,
                             memidConstructor :: MEMBERID,
                             memidDestructor :: MEMBERID,
                             lpstrSchema :: LPOLESTR,
                             cbSizeInstance :: ULONG,
                             typekind :: TYPEKIND,
                             cFuncs :: WORD,
                             cVars :: WORD,
                             cImplTypes :: WORD,
                             cbSizeVft :: WORD,
                             cbAlignment :: WORD,
                             wTypeFlags :: WORD,
                             wMajorVerNum :: WORD,
                             wMinorVerNum :: WORD,
                             tdescAlias :: TYPEDESC,
                             idldescType :: IDLDESC}
                  
writeTYPEATTR :: Ptr TYPEATTR
              -> TYPEATTR
              -> IO ()
writeTYPEATTR ptr (TagTYPEATTR guid lcid dwReserved0 memidConstructor memidDestructor lpstrSchema cbSizeInstance typekind cFuncs cVars cImplTypes cbSizeVft cbAlignment wTypeFlags wMajorVerNum wMinorVerNum tdescAlias idldescType) =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    writeGUID pf1 guid
    let pf2 = addNCastPtr pf1 16
    writeWord32 pf2 lcid
    let pf3 = addNCastPtr pf2 4
    writeWord32 pf3 dwReserved0
    let pf4 = addNCastPtr pf3 4
    writeInt32 pf4 memidConstructor
    let pf5 = addNCastPtr pf4 4
    writeInt32 pf5 memidDestructor
    let pf6 = addNCastPtr pf5 4
    writeWideString pf6 lpstrSchema
    let pf7 = addNCastPtr pf6 4
    writeWord32 pf7 cbSizeInstance
    let pf8 = addNCastPtr pf7 4
    writeEnum32 pf8 typekind
    let pf9 = addNCastPtr pf8 4
    writeWord16 pf9 cFuncs
    let pf10 = addNCastPtr pf9 2
    writeWord16 pf10 cVars
    let pf11 = addNCastPtr pf10 2
    writeWord16 pf11 cImplTypes
    let pf12 = addNCastPtr pf11 2
    writeWord16 pf12 cbSizeVft
    let pf13 = addNCastPtr pf12 2
    writeWord16 pf13 cbAlignment
    let pf14 = addNCastPtr pf13 2
    writeWord16 pf14 wTypeFlags
    let pf15 = addNCastPtr pf14 2
    writeWord16 pf15 wMajorVerNum
    let pf16 = addNCastPtr pf15 2
    writeWord16 pf16 wMinorVerNum
    let pf17 = addNCastPtr pf16 2
    writeTYPEDESC pf17 tdescAlias
    let pf18 = addNCastPtr pf17 8
    writeIDLDESC pf18 idldescType

readTYPEATTR :: Bool
             -> Ptr TYPEATTR
             -> IO TYPEATTR
readTYPEATTR finaliseMe__ ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    guid <- readGUID finaliseMe__ pf1
    let pf2 = addNCastPtr pf1 16
    lcid <- readWord32 pf2
    let pf3 = addNCastPtr pf2 4
    dwReserved0 <- readWord32 pf3
    let pf4 = addNCastPtr pf3 4
    memidConstructor <- readInt32 pf4
    let pf5 = addNCastPtr pf4 4
    memidDestructor <- readInt32 pf5
    let pf6 = addNCastPtr pf5 4
    lpstrSchema <- readWideString pf6
    let pf7 = addNCastPtr pf6 4
    cbSizeInstance <- readWord32 pf7
    let pf8 = addNCastPtr pf7 4
    typekind <- readEnum32 pf8
    let pf9 = addNCastPtr pf8 4
    cFuncs <- readWord16 pf9
    let pf10 = addNCastPtr pf9 2
    cVars <- readWord16 pf10
    let pf11 = addNCastPtr pf10 2
    cImplTypes <- readWord16 pf11
    let pf12 = addNCastPtr pf11 2
    cbSizeVft <- readWord16 pf12
    let pf13 = addNCastPtr pf12 2
    cbAlignment <- readWord16 pf13
    let pf14 = addNCastPtr pf13 2
    wTypeFlags <- readWord16 pf14
    let pf15 = addNCastPtr pf14 2
    wMajorVerNum <- readWord16 pf15
    let pf16 = addNCastPtr pf15 2
    wMinorVerNum <- readWord16 pf16
    let pf17 = addNCastPtr pf16 2
    tdescAlias <- readTYPEDESC pf17
    let pf18 = addNCastPtr pf17 8
    idldescType <- readIDLDESC pf18
    return (TagTYPEATTR guid lcid dwReserved0 memidConstructor memidDestructor lpstrSchema cbSizeInstance typekind cFuncs cVars cImplTypes cbSizeVft cbAlignment wTypeFlags wMajorVerNum wMinorVerNum tdescAlias idldescType)

sizeofTYPEATTR :: Word32
sizeofTYPEATTR = 76

type LPTYPEATTR = TYPEATTR
data DISPPARAMS = TagDISPPARAMS {rgvarg :: [VARIANT],
                                 rgdispidNamedArgs :: [Int32]}
                    
freeDISPPARAMS :: Ptr DISPPARAMS
               -> IO ()
freeDISPPARAMS ptr =
  let
   struct_ptr__ = addNCastPtr ptr 0
  in
  do
    field_ptr__ <- derefPtr struct_ptr__
    free field_ptr__

writeDISPPARAMS :: Ptr DISPPARAMS
                -> DISPPARAMS
                -> IO ()
writeDISPPARAMS ptr (TagDISPPARAMS rgvarg rgdispidNamedArgs) =
  let
   cArgs = (fromIntegral (length rgvarg) :: Word32)
  in
  do
    rgvarg <- marshalllist sizeofVARIANT writeVARIANT rgvarg
    let cNamedArgs = (fromIntegral (length rgdispidNamedArgs) :: Word32)
    rgdispidNamedArgs <- marshalllist sizeofInt32 writeInt32 rgdispidNamedArgs
    let pf0 = ptr
        pf1 = addNCastPtr pf0 0
    writePtr pf1 rgvarg
    let pf2 = addNCastPtr pf1 4
    writePtr pf2 rgdispidNamedArgs
    let pf3 = addNCastPtr pf2 4
    writeWord32 pf3 cArgs
    let pf4 = addNCastPtr pf3 4
    writeWord32 pf4 cNamedArgs

readDISPPARAMS :: Ptr DISPPARAMS
               -> IO DISPPARAMS
readDISPPARAMS ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    rgvarg <- readPtr pf1
    let pf2 = addNCastPtr pf1 4
    rgdispidNamedArgs <- readPtr pf2
    let pf3 = addNCastPtr pf2 4
    cArgs <- readWord32 pf3
    let pf4 = addNCastPtr pf3 4
    cNamedArgs <- readWord32 pf4
    cArgs <- unmarshallWord32 cArgs
    cNamedArgs <- unmarshallWord32 cNamedArgs
    rgvarg <- unmarshalllist sizeofVARIANT 0 ((fromIntegral cArgs :: Word32)) readVARIANT rgvarg
    rgdispidNamedArgs <- unmarshalllist sizeofInt32 0 ((fromIntegral cNamedArgs :: Word32)) readInt32 rgdispidNamedArgs
    return (TagDISPPARAMS rgvarg rgdispidNamedArgs)

sizeofDISPPARAMS :: Word32
sizeofDISPPARAMS = 16

{- BEGIN_C_CODE
#if 0
END_C_CODE-}
{- BEGIN_C_CODE
/* the following is what MIDL knows how to remote */
END_C_CODE-}
data EXCEPINFO = TagEXCEPINFO {wCode :: WORD,
                               wReserved :: WORD,
                               bstrSource :: String,
                               bstrDescription :: String,
                               bstrHelpFile :: String,
                               dwHelpContext :: DWORD,
                               pvReserved :: ULONG,
                               pfnDeferredFillIn :: ULONG,
                               scode :: SCODE}
                   
freeEXCEPINFO :: Ptr EXCEPINFO
              -> IO ()
freeEXCEPINFO ptr =
  do
    let struct_ptr__ = addNCastPtr ptr 4
    freeBSTR struct_ptr__
    let struct_ptr__ = addNCastPtr ptr 8
    freeBSTR struct_ptr__
    let struct_ptr__ = addNCastPtr ptr 12
    freeBSTR struct_ptr__

writeEXCEPINFO :: Ptr EXCEPINFO
               -> EXCEPINFO
               -> IO ()
writeEXCEPINFO ptr (TagEXCEPINFO wCode wReserved bstrSource bstrDescription bstrHelpFile dwHelpContext pvReserved pfnDeferredFillIn scode) =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    writeWord16 pf1 wCode
    let pf2 = addNCastPtr pf1 2
    writeWord16 pf2 wReserved
    let pf3 = addNCastPtr pf2 2
    writeBSTR pf3 bstrSource
    let pf4 = addNCastPtr pf3 4
    writeBSTR pf4 bstrDescription
    let pf5 = addNCastPtr pf4 4
    writeBSTR pf5 bstrHelpFile
    let pf6 = addNCastPtr pf5 4
    writeWord32 pf6 dwHelpContext
    let pf7 = addNCastPtr pf6 4
    writeWord32 pf7 pvReserved
    let pf8 = addNCastPtr pf7 4
    writeWord32 pf8 pfnDeferredFillIn
    let pf9 = addNCastPtr pf8 4
    writeInt32 pf9 scode

readEXCEPINFO :: Ptr EXCEPINFO
              -> IO EXCEPINFO
readEXCEPINFO ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    wCode <- readWord16 pf1
    let pf2 = addNCastPtr pf1 2
    wReserved <- readWord16 pf2
    let pf3 = addNCastPtr pf2 2
    bstrSource <- readBSTR pf3
    let pf4 = addNCastPtr pf3 4
    bstrDescription <- readBSTR pf4
    let pf5 = addNCastPtr pf4 4
    bstrHelpFile <- readBSTR pf5
    let pf6 = addNCastPtr pf5 4
    dwHelpContext <- readWord32 pf6
    let pf7 = addNCastPtr pf6 4
    pvReserved <- readWord32 pf7
    let pf8 = addNCastPtr pf7 4
    pfnDeferredFillIn <- readWord32 pf8
    let pf9 = addNCastPtr pf8 4
    scode <- readInt32 pf9
    return (TagEXCEPINFO wCode wReserved bstrSource bstrDescription bstrHelpFile dwHelpContext pvReserved pfnDeferredFillIn scode)

sizeofEXCEPINFO :: Word32
sizeofEXCEPINFO = 32

{- BEGIN_C_CODE
#else /* 0 */
END_C_CODE-}
{- BEGIN_C_CODE
typedef struct tagEXCEPINFO {
END_C_CODE-}
{- BEGIN_C_CODE
    WORD  wCode;
END_C_CODE-}
{- BEGIN_C_CODE
    WORD  wReserved;
END_C_CODE-}
{- BEGIN_C_CODE
    BSTR  bstrSource;
END_C_CODE-}
{- BEGIN_C_CODE
    BSTR  bstrDescription;
END_C_CODE-}
{- BEGIN_C_CODE
    BSTR  bstrHelpFile;
END_C_CODE-}
{- BEGIN_C_CODE
    DWORD dwHelpContext;
END_C_CODE-}
{- BEGIN_C_CODE
    PVOID pvReserved;
END_C_CODE-}
{- BEGIN_C_CODE
    HRESULT (__stdcall *pfnDeferredFillIn)(struct tagEXCEPINFO *);
END_C_CODE-}
{- BEGIN_C_CODE
    SCODE scode;
END_C_CODE-}
{- BEGIN_C_CODE
} EXCEPINFO, * LPEXCEPINFO;
END_C_CODE-}
{- BEGIN_C_CODE
#endif /* 0 */
END_C_CODE-}
data CALLCONV
 = CC_FASTCALL
 | CC_CDECL
 | CC_MSCPASCAL
 | CC_PASCAL
 | CC_MACPASCAL
 | CC_STDCALL
 | CC_FPFASTCALL
 | CC_SYSCALL
 | CC_MPWCDECL
 | CC_MPWPASCAL
 | CC_MAX
 
instance Enum (CALLCONV) where
  fromEnum v =
    case v of
       CC_FASTCALL -> 0
       CC_CDECL -> 1
       CC_MSCPASCAL -> 2
       CC_PASCAL -> 2
       CC_MACPASCAL -> 3
       CC_STDCALL -> 4
       CC_FPFASTCALL -> 5
       CC_SYSCALL -> 6
       CC_MPWCDECL -> 7
       CC_MPWPASCAL -> 8
       CC_MAX -> 9
  
  toEnum v =
    case v of
       0 -> CC_FASTCALL
       1 -> CC_CDECL
       2 -> CC_MSCPASCAL
       2 -> CC_PASCAL
       3 -> CC_MACPASCAL
       4 -> CC_STDCALL
       5 -> CC_FPFASTCALL
       6 -> CC_SYSCALL
       7 -> CC_MPWCDECL
       8 -> CC_MPWPASCAL
       9 -> CC_MAX
       _ -> error "unmarshallCALLCONV: illegal enum value "
  
data FUNCKIND
 = FUNC_VIRTUAL
 | FUNC_PUREVIRTUAL
 | FUNC_NONVIRTUAL
 | FUNC_STATIC
 | FUNC_DISPATCH
 deriving (Enum)
data INVOKEKIND
 = INVOKEKINDList__ [INVOKEKIND]
 | INVOKE_FUNC
 | INVOKE_PROPERTYGET
 | INVOKE_PROPERTYPUT
 | INVOKE_PROPERTYPUTREF
 
instance Flags (INVOKEKIND) where
  x1 .+. x2
    = toEnum ((fromEnum x1 + fromEnum x2))
  
instance Enum (INVOKEKIND) where
  fromEnum v =
    case v of
       (INVOKEKINDList__ xs) -> orList (map fromEnum xs)
       INVOKE_FUNC -> 1
       INVOKE_PROPERTYGET -> 2
       INVOKE_PROPERTYPUT -> 4
       INVOKE_PROPERTYPUTREF -> 8
  
  toEnum v =
    case v of
       1 -> INVOKE_FUNC
       2 -> INVOKE_PROPERTYGET
       4 -> INVOKE_PROPERTYPUT
       8 -> INVOKE_PROPERTYPUTREF
       x -> INVOKEKINDList__ (mapMaybe (\ val -> if ((val .&. fromIntegral x) == val)
                                                   then Just (toEnum (fromIntegral val))
                                                   else Nothing) (pow2Series 4 1))
       _ -> error "unmarshallINVOKEKIND: illegal enum value "
  
data VARKIND
 = VAR_PERINSTANCE
 | VAR_STATIC
 | VAR_CONST
 | VAR_DISPATCH
 deriving (Enum)
data FUNCDESC = TagFUNCDESC {memid :: MEMBERID,
                             lprgscode :: [Int32],
                             lprgelemdescParam :: [ELEMDESC],
                             funckind :: FUNCKIND,
                             invkind :: INVOKEKIND,
                             callconv :: CALLCONV,
                             cParamsOpt :: SHORT,
                             oVft :: SHORT,
                             elemdescFunc :: ELEMDESC,
                             wFuncFlags :: WORD}
                  
freeFUNCDESC :: Ptr FUNCDESC
             -> IO ()
freeFUNCDESC ptr =
  do
    let struct_ptr__ = addNCastPtr ptr 8
    field_ptr__ <- derefPtr struct_ptr__
    free field_ptr__
    let struct_ptr__ = addNCastPtr ptr 32
    trivialFree struct_ptr__

writeFUNCDESC :: Ptr FUNCDESC
              -> FUNCDESC
              -> IO ()
writeFUNCDESC ptr (TagFUNCDESC memid lprgscode lprgelemdescParam funckind invkind callconv cParamsOpt oVft elemdescFunc wFuncFlags) =
  let
   cScodes = (fromIntegral (length lprgscode) :: Int16)
  in
  do
    lprgscode <- marshalllist sizeofInt32 writeInt32 lprgscode
    let cParams = (fromIntegral (length lprgelemdescParam) :: Int16)
    lprgelemdescParam <- marshalllist sizeofELEMDESC writeELEMDESC lprgelemdescParam
    let pf0 = ptr
        pf1 = addNCastPtr pf0 0
    writeInt32 pf1 memid
    let pf2 = addNCastPtr pf1 4
    writePtr pf2 lprgscode
    let pf3 = addNCastPtr pf2 4
    writePtr pf3 lprgelemdescParam
    let pf4 = addNCastPtr pf3 4
    writeEnum32 pf4 funckind
    let pf5 = addNCastPtr pf4 4
    writeEnum32 pf5 invkind
    let pf6 = addNCastPtr pf5 4
    writeEnum32 pf6 callconv
    let pf7 = addNCastPtr pf6 4
    writeInt16 pf7 cParams
    let pf8 = addNCastPtr pf7 2
    writeInt16 pf8 cParamsOpt
    let pf9 = addNCastPtr pf8 2
    writeInt16 pf9 oVft
    let pf10 = addNCastPtr pf9 2
    writeInt16 pf10 cScodes
    let pf11 = addNCastPtr pf10 2
    writeELEMDESC pf11 elemdescFunc
    let pf12 = addNCastPtr pf11 16
    writeWord16 pf12 wFuncFlags

readFUNCDESC :: Ptr FUNCDESC
             -> IO FUNCDESC
readFUNCDESC ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    memid <- readInt32 pf1
    let pf2 = addNCastPtr pf1 4
    lprgscode <- readPtr pf2
    let pf3 = addNCastPtr pf2 4
    lprgelemdescParam <- readPtr pf3
    let pf4 = addNCastPtr pf3 4
    funckind <- readEnum32 pf4
    let pf5 = addNCastPtr pf4 4
    invkind <- readEnum32 pf5
    let pf6 = addNCastPtr pf5 4
    callconv <- readEnum32 pf6
    let pf7 = addNCastPtr pf6 4
    cParams <- readInt16 pf7
    let pf8 = addNCastPtr pf7 2
    cParamsOpt <- readInt16 pf8
    let pf9 = addNCastPtr pf8 2
    oVft <- readInt16 pf9
    let pf10 = addNCastPtr pf9 2
    cScodes <- readInt16 pf10
    let pf11 = addNCastPtr pf10 2
    elemdescFunc <- readELEMDESC pf11
    let pf12 = addNCastPtr pf11 16
    wFuncFlags <- readWord16 pf12
    cScodes <- unmarshallInt16 cScodes
    cParams <- unmarshallInt16 cParams
    lprgscode <- unmarshalllist sizeofInt32 0 ((fromIntegral cScodes :: Word32)) readInt32 lprgscode
    lprgelemdescParam <- unmarshalllist sizeofELEMDESC 0 ((fromIntegral cParams :: Word32)) readELEMDESC lprgelemdescParam
    return (TagFUNCDESC memid lprgscode lprgelemdescParam funckind invkind callconv cParamsOpt oVft elemdescFunc wFuncFlags)

sizeofFUNCDESC :: Word32
sizeofFUNCDESC = 52

type LPFUNCDESC = FUNCDESC
iMPLTYPEFLAG_FDEFAULT :: USHORT
iMPLTYPEFLAG_FDEFAULT = 0x1

iMPLTYPEFLAG_FSOURCE :: USHORT
iMPLTYPEFLAG_FSOURCE = 0x2

iMPLTYPEFLAG_FRESTRICTED :: USHORT
iMPLTYPEFLAG_FRESTRICTED = 0x4

iMPLTYPEFLAG_FDEFAULTVTABLE :: USHORT
iMPLTYPEFLAG_FDEFAULTVTABLE = 0x8

data IHC_TAG_9
 = OInst ULONG
 | LpvarValue (Maybe VARIANT)
 
marshallIHC_TAG_9 :: IHC_TAG_9
                  -> IO (IHC_TAG_9, Int32)
marshallIHC_TAG_9 = marshallUnion "marshallIHC_TAG_9"

unmarshallIHC_TAG_9 :: IHC_TAG_9
                    -> Int32
                    -> IO IHC_TAG_9
unmarshallIHC_TAG_9 = unmarshallUnion "unmarshallIHC_TAG_9"

writeIHC_TAG_9 :: (Int32 -> IO ())
               -> Ptr IHC_TAG_9
               -> IHC_TAG_9
               -> IO ()
writeIHC_TAG_9 write_tag ptr v =
  case v of
     (OInst oInst) -> do
                        write_tag 0
                        writeWord32 (castPtr ptr) oInst
     (LpvarValue lpvarValue) -> do
                                  write_tag 2
                                  writeMaybe writeVARIANT (castPtr ptr) lpvarValue

readIHC_TAG_9 :: IO Int32
              -> Ptr IHC_TAG_9
              -> IO IHC_TAG_9
readIHC_TAG_9 read_tag ptr =
  do
    tag <- read_tag
    case tag of
       0 -> do
              v <- readWord32 (castPtr ptr)
              return (OInst v)
       3 -> do
              v <- readWord32 (castPtr ptr)
              return (OInst v)
       1 -> do
              v <- readWord32 (castPtr ptr)
              return (OInst v)
       2 -> do
              v <- readMaybe readVARIANT (castPtr ptr)
              return (LpvarValue v)

sizeofIHC_TAG_9 :: Word32
sizeofIHC_TAG_9 = 4

freeIHC_TAG_9 :: Int32
              -> Ptr IHC_TAG_9
              -> IO ()
freeIHC_TAG_9 read_tag ptr =
  do
    tag <- return (read_tag)
    case tag of
       0 -> return ()
       3 -> return ()
       1 -> return ()
       2 -> free (castPtr ptr)

type IHC_TAG_8 = IHC_TAG_9
data VARDESC = TagVARDESC {memid0 :: MEMBERID,
                           lpstrSchema0 :: LPOLESTR,
                           iHC_TAG_7 :: IHC_TAG_9,
                           elemdescVar :: ELEMDESC,
                           wVarFlags :: WORD,
                           varkind :: VARKIND}
                 
freeVARDESC :: Ptr VARDESC
            -> IO ()
freeVARDESC ptr =
  do
    varkind <- readInt32 (addNCastPtr ptr 32)
    return ()
    let struct_ptr__ = addNCastPtr ptr 4
    trivialFree struct_ptr__
    let struct_ptr__ = addNCastPtr ptr 8
    trivialFree struct_ptr__
    let struct_ptr__ = addNCastPtr ptr 12
    trivialFree struct_ptr__

writeVARDESC :: Ptr VARDESC
             -> VARDESC
             -> IO ()
writeVARDESC ptr (TagVARDESC memid0 lpstrSchema0 iHC_TAG_7 elemdescVar wVarFlags varkind) =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    writeInt32 pf1 memid0
    let pf2 = addNCastPtr pf1 4
    writeWideString pf2 lpstrSchema0
    let pf3 = addNCastPtr pf2 4
    writeIHC_TAG_9 (writeInt32 (addNCastPtr pf0 32)) pf3 iHC_TAG_7
    let pf4 = addNCastPtr pf3 4
    writeELEMDESC pf4 elemdescVar
    let pf5 = addNCastPtr pf4 16
    writeWord16 pf5 wVarFlags
    let pf6 = addNCastPtr pf5 4
    writeEnum32 pf6 varkind

readVARDESC :: Ptr VARDESC
            -> IO VARDESC
readVARDESC ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    memid0 <- readInt32 pf1
    let pf2 = addNCastPtr pf1 4
    lpstrSchema0 <- readWideString pf2
    let pf3 = addNCastPtr pf2 4
    iHC_TAG_7 <- readIHC_TAG_9 (readInt32 (addNCastPtr pf0 32)) pf3
    let pf4 = addNCastPtr pf3 4
    elemdescVar <- readELEMDESC pf4
    let pf5 = addNCastPtr pf4 16
    wVarFlags <- readWord16 pf5
    let pf6 = addNCastPtr pf5 4
    varkind <- readEnum32 pf6
    return (TagVARDESC memid0 lpstrSchema0 iHC_TAG_7 elemdescVar wVarFlags varkind)

sizeofVARDESC :: Word32
sizeofVARDESC = 36

type LPVARDESC = VARDESC
data TYPEFLAGS
 = TYPEFLAGSList__ [TYPEFLAGS]
 | TYPEFLAG_FAPPOBJECT
 | TYPEFLAG_FCANCREATE
 | TYPEFLAG_FLICENSED
 | TYPEFLAG_FPREDECLID
 | TYPEFLAG_FHIDDEN
 | TYPEFLAG_FCONTROL
 | TYPEFLAG_FDUAL
 | TYPEFLAG_FNONEXTENSIBLE
 | TYPEFLAG_FOLEAUTOMATION
 | TYPEFLAG_FRESTRICTED
 | TYPEFLAG_FAGGREGATABLE
 | TYPEFLAG_FREPLACEABLE
 | TYPEFLAG_FDISPATCHABLE
 | TYPEFLAG_FREVERSEBIND
 
instance Flags (TYPEFLAGS) where
  x1 .+. x2
    = toEnum ((fromEnum x1 + fromEnum x2))
  
instance Enum (TYPEFLAGS) where
  fromEnum v =
    case v of
       (TYPEFLAGSList__ xs) -> orList (map fromEnum xs)
       TYPEFLAG_FAPPOBJECT -> 1
       TYPEFLAG_FCANCREATE -> 2
       TYPEFLAG_FLICENSED -> 4
       TYPEFLAG_FPREDECLID -> 8
       TYPEFLAG_FHIDDEN -> 16
       TYPEFLAG_FCONTROL -> 32
       TYPEFLAG_FDUAL -> 64
       TYPEFLAG_FNONEXTENSIBLE -> 128
       TYPEFLAG_FOLEAUTOMATION -> 256
       TYPEFLAG_FRESTRICTED -> 512
       TYPEFLAG_FAGGREGATABLE -> 1024
       TYPEFLAG_FREPLACEABLE -> 2048
       TYPEFLAG_FDISPATCHABLE -> 4096
       TYPEFLAG_FREVERSEBIND -> 8192
  
  toEnum v =
    case v of
       1 -> TYPEFLAG_FAPPOBJECT
       2 -> TYPEFLAG_FCANCREATE
       4 -> TYPEFLAG_FLICENSED
       8 -> TYPEFLAG_FPREDECLID
       16 -> TYPEFLAG_FHIDDEN
       32 -> TYPEFLAG_FCONTROL
       64 -> TYPEFLAG_FDUAL
       128 -> TYPEFLAG_FNONEXTENSIBLE
       256 -> TYPEFLAG_FOLEAUTOMATION
       512 -> TYPEFLAG_FRESTRICTED
       1024 -> TYPEFLAG_FAGGREGATABLE
       2048 -> TYPEFLAG_FREPLACEABLE
       4096 -> TYPEFLAG_FDISPATCHABLE
       8192 -> TYPEFLAG_FREVERSEBIND
       x -> TYPEFLAGSList__ (mapMaybe (\ val -> if ((val .&. fromIntegral x) == val)
                                                  then Just (toEnum (fromIntegral val))
                                                  else Nothing) (pow2Series 14 1))
       _ -> error "unmarshallTYPEFLAGS: illegal enum value "
  
data FUNCFLAGS
 = FUNCFLAGSList__ [FUNCFLAGS]
 | FUNCFLAG_FRESTRICTED
 | FUNCFLAG_FSOURCE
 | FUNCFLAG_FBINDABLE
 | FUNCFLAG_FREQUESTEDIT
 | FUNCFLAG_FDISPLAYBIND
 | FUNCFLAG_FDEFAULTBIND
 | FUNCFLAG_FHIDDEN
 | FUNCFLAG_FUSESGETLASTERROR
 | FUNCFLAG_FDEFAULTCOLLELEM
 | FUNCFLAG_FUIDEFAULT
 | FUNCFLAG_FNONBROWSABLE
 | FUNCFLAG_FREPLACEABLE
 | FUNCFLAG_FIMMEDIATEBIND
 
instance Flags (FUNCFLAGS) where
  x1 .+. x2
    = toEnum ((fromEnum x1 + fromEnum x2))
  
instance Enum (FUNCFLAGS) where
  fromEnum v =
    case v of
       (FUNCFLAGSList__ xs) -> orList (map fromEnum xs)
       FUNCFLAG_FRESTRICTED -> 1
       FUNCFLAG_FSOURCE -> 2
       FUNCFLAG_FBINDABLE -> 4
       FUNCFLAG_FREQUESTEDIT -> 8
       FUNCFLAG_FDISPLAYBIND -> 16
       FUNCFLAG_FDEFAULTBIND -> 32
       FUNCFLAG_FHIDDEN -> 64
       FUNCFLAG_FUSESGETLASTERROR -> 128
       FUNCFLAG_FDEFAULTCOLLELEM -> 256
       FUNCFLAG_FUIDEFAULT -> 512
       FUNCFLAG_FNONBROWSABLE -> 1024
       FUNCFLAG_FREPLACEABLE -> 2048
       FUNCFLAG_FIMMEDIATEBIND -> 4096
  
  toEnum v =
    case v of
       1 -> FUNCFLAG_FRESTRICTED
       2 -> FUNCFLAG_FSOURCE
       4 -> FUNCFLAG_FBINDABLE
       8 -> FUNCFLAG_FREQUESTEDIT
       16 -> FUNCFLAG_FDISPLAYBIND
       32 -> FUNCFLAG_FDEFAULTBIND
       64 -> FUNCFLAG_FHIDDEN
       128 -> FUNCFLAG_FUSESGETLASTERROR
       256 -> FUNCFLAG_FDEFAULTCOLLELEM
       512 -> FUNCFLAG_FUIDEFAULT
       1024 -> FUNCFLAG_FNONBROWSABLE
       2048 -> FUNCFLAG_FREPLACEABLE
       4096 -> FUNCFLAG_FIMMEDIATEBIND
       x -> FUNCFLAGSList__ (mapMaybe (\ val -> if ((val .&. fromIntegral x) == val)
                                                  then Just (toEnum (fromIntegral val))
                                                  else Nothing) (pow2Series 13 1))
       _ -> error "unmarshallFUNCFLAGS: illegal enum value "
  
data VARFLAGS
 = VARFLAGSList__ [VARFLAGS]
 | VARFLAG_FREADONLY
 | VARFLAG_FSOURCE
 | VARFLAG_FBINDABLE
 | VARFLAG_FREQUESTEDIT
 | VARFLAG_FDISPLAYBIND
 | VARFLAG_FDEFAULTBIND
 | VARFLAG_FHIDDEN
 | VARFLAG_FRESTRICTED
 | VARFLAG_FDEFAULTCOLLELEM
 | VARFLAG_FUIDEFAULT
 | VARFLAG_FNONBROWSABLE
 | VARFLAG_FREPLACEABLE
 | VARFLAG_FIMMEDIATEBIND
 
instance Flags (VARFLAGS) where
  x1 .+. x2
    = toEnum ((fromEnum x1 + fromEnum x2))
  
instance Enum (VARFLAGS) where
  fromEnum v =
    case v of
       (VARFLAGSList__ xs) -> orList (map fromEnum xs)
       VARFLAG_FREADONLY -> 1
       VARFLAG_FSOURCE -> 2
       VARFLAG_FBINDABLE -> 4
       VARFLAG_FREQUESTEDIT -> 8
       VARFLAG_FDISPLAYBIND -> 16
       VARFLAG_FDEFAULTBIND -> 32
       VARFLAG_FHIDDEN -> 64
       VARFLAG_FRESTRICTED -> 128
       VARFLAG_FDEFAULTCOLLELEM -> 256
       VARFLAG_FUIDEFAULT -> 512
       VARFLAG_FNONBROWSABLE -> 1024
       VARFLAG_FREPLACEABLE -> 2048
       VARFLAG_FIMMEDIATEBIND -> 4096
  
  toEnum v =
    case v of
       1 -> VARFLAG_FREADONLY
       2 -> VARFLAG_FSOURCE
       4 -> VARFLAG_FBINDABLE
       8 -> VARFLAG_FREQUESTEDIT
       16 -> VARFLAG_FDISPLAYBIND
       32 -> VARFLAG_FDEFAULTBIND
       64 -> VARFLAG_FHIDDEN
       128 -> VARFLAG_FRESTRICTED
       256 -> VARFLAG_FDEFAULTCOLLELEM
       512 -> VARFLAG_FUIDEFAULT
       1024 -> VARFLAG_FNONBROWSABLE
       2048 -> VARFLAG_FREPLACEABLE
       4096 -> VARFLAG_FIMMEDIATEBIND
       x -> VARFLAGSList__ (mapMaybe (\ val -> if ((val .&. fromIntegral x) == val)
                                                 then Just (toEnum (fromIntegral val))
                                                 else Nothing) (pow2Series 13 1))
       _ -> error "unmarshallVARFLAGS: illegal enum value "
  
data CLEANLOCALSTORAGE = TagCLEANLOCALSTORAGE {pInterface :: (IUnknown ()),
                                               pStorage :: PVOID,
                                               flags :: DWORD}
                           
writeCLEANLOCALSTORAGE :: Bool
                       -> Ptr CLEANLOCALSTORAGE
                       -> CLEANLOCALSTORAGE
                       -> IO ()
writeCLEANLOCALSTORAGE addRefMe__ ptr (TagCLEANLOCALSTORAGE pInterface pStorage flags) =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    writeIUnknown addRefMe__ pf1 pInterface
    let pf2 = addNCastPtr pf1 4
    writePtr pf2 pStorage
    let pf3 = addNCastPtr pf2 4
    writeWord32 pf3 flags

readCLEANLOCALSTORAGE :: Bool
                      -> Ptr CLEANLOCALSTORAGE
                      -> IO CLEANLOCALSTORAGE
readCLEANLOCALSTORAGE finaliseMe__ ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    pInterface <- readIUnknown finaliseMe__ pf1
    let pf2 = addNCastPtr pf1 4
    pStorage <- readPtr pf2
    let pf3 = addNCastPtr pf2 4
    flags <- readWord32 pf3
    return (TagCLEANLOCALSTORAGE pInterface pStorage flags)

sizeofCLEANLOCALSTORAGE :: Word32
sizeofCLEANLOCALSTORAGE = 12

data CUSTDATAITEM = TagCUSTDATAITEM {guid0 :: GUID,
                                     varValue :: VARIANT}
                      
freeCUSTDATAITEM :: Ptr CUSTDATAITEM
                 -> IO ()
freeCUSTDATAITEM ptr =
  let
   struct_ptr__ = addNCastPtr ptr 16
  in
  trivialFree struct_ptr__

writeCUSTDATAITEM :: Ptr CUSTDATAITEM
                  -> CUSTDATAITEM
                  -> IO ()
writeCUSTDATAITEM ptr (TagCUSTDATAITEM guid0 varValue) =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    writeGUID pf1 guid0
    let pf2 = addNCastPtr pf1 16
    copyVARIANT pf2 varValue

readCUSTDATAITEM :: Bool
                 -> Ptr CUSTDATAITEM
                 -> IO CUSTDATAITEM
readCUSTDATAITEM finaliseMe__ ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    guid0 <- readGUID finaliseMe__ pf1
    let pf2 = addNCastPtr pf1 16
    varValue <- unmarshallVARIANT pf2
    return (TagCUSTDATAITEM guid0 varValue)

sizeofCUSTDATAITEM :: Word32
sizeofCUSTDATAITEM = 32

type LPCUSTDATAITEM = CUSTDATAITEM
data CUSTDATA = TagCUSTDATA {prgCustData :: [CUSTDATAITEM]}
                  
freeCUSTDATA :: Ptr CUSTDATA
             -> IO ()
freeCUSTDATA ptr =
  let
   struct_ptr__ = addNCastPtr ptr 4
  in
  trivialFree struct_ptr__

writeCUSTDATA :: Ptr CUSTDATA
              -> CUSTDATA
              -> IO ()
writeCUSTDATA ptr (TagCUSTDATA prgCustData) =
  let
   cCustData = (fromIntegral (length prgCustData) :: Word32)
  in
  do
    prgCustData <- marshalllist sizeofCUSTDATAITEM writeCUSTDATAITEM prgCustData
    let pf0 = ptr
        pf1 = addNCastPtr pf0 0
    writeWord32 pf1 cCustData
    let pf2 = addNCastPtr pf1 4
    writePtr pf2 prgCustData

readCUSTDATA :: Bool
             -> Ptr CUSTDATA
             -> IO CUSTDATA
readCUSTDATA finaliseMe__ ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    cCustData <- readWord32 pf1
    let pf2 = addNCastPtr pf1 4
    prgCustData <- readPtr pf2
    cCustData <- unmarshallWord32 cCustData
    prgCustData <- unmarshalllist sizeofCUSTDATAITEM 0 ((fromIntegral cCustData :: Word32)) (readCUSTDATAITEM finaliseMe__) prgCustData
    return (TagCUSTDATA prgCustData)

sizeofCUSTDATA :: Word32
sizeofCUSTDATA = 8

type LPCUSTDATA = CUSTDATA
-- --------------------------------------------------
-- 
-- interface ICreateTypeInfo
-- 
-- --------------------------------------------------
data ICreateTypeInfo_ a = ICreateTypeInfo__
                            
type ICreateTypeInfo a = IUnknown (ICreateTypeInfo_ a)
iidICreateTypeInfo :: IID (ICreateTypeInfo ())
iidICreateTypeInfo = mkIID "{00020405-0000-0000-C000-000000000046}"

type LPCREATETYPEINFO = Maybe (ICreateTypeInfo ())
setGuid :: REFGUID
        -> ICreateTypeInfo a0
        -> IO ()
setGuid guid1 iptr =
  do
    guid1 <- marshallGUID guid1
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid1 (\ guid1 -> prim_TypeLib_setGuid methPtr iptr guid1)) 3 iptr

foreign import stdcall "dynamic" prim_TypeLib_setGuid :: Ptr () -> Ptr () -> Ptr GUID -> IO Int32
setTypeFlags :: UINT
             -> ICreateTypeInfo a0
             -> IO ()
setTypeFlags uTypeFlags iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setTypeFlags methPtr iptr uTypeFlags)
                 4
                 iptr

foreign import stdcall "dynamic" prim_TypeLib_setTypeFlags :: Ptr () -> Ptr () -> Word32 -> IO Int32
setDocString :: LPOLESTR
             -> ICreateTypeInfo a0
             -> IO ()
setDocString pStrDoc iptr =
  do
    pStrDoc <- marshallWideString pStrDoc
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setDocString methPtr iptr pStrDoc) 5 iptr
    freeWideString pStrDoc

foreign import stdcall "dynamic" prim_TypeLib_setDocString :: Ptr () -> Ptr () -> Ptr WideString -> IO Int32
setHelpContext :: DWORD
               -> ICreateTypeInfo a0
               -> IO ()
setHelpContext dwHelpContext0 iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setTypeFlags methPtr iptr dwHelpContext0)
                 6
                 iptr

setVersion :: WORD
           -> WORD
           -> ICreateTypeInfo a0
           -> IO ()
setVersion wMajorVerNum0 wMinorVerNum0 iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setVersion methPtr iptr wMajorVerNum0 wMinorVerNum0)
                 7
                 iptr

foreign import stdcall "dynamic" prim_TypeLib_setVersion :: Ptr () -> Ptr () -> Word16 -> Word16 -> IO Int32
addRefTypeInfo :: ITypeInfo a1
               -> ICreateTypeInfo a0
               -> IO HREFTYPE
addRefTypeInfo pTInfo iptr =
  do
    phRefType <- allocBytes (fromIntegral sizeofWord32)
    pTInfo <- marshallIUnknown pTInfo
    invokeAndCheck (\ methPtr iptr -> withForeignPtr pTInfo (\ pTInfo -> prim_TypeLib_addRefTypeInfo methPtr iptr pTInfo phRefType)) 8 iptr
    doThenFree free readWord32 phRefType

foreign import stdcall "dynamic" prim_TypeLib_addRefTypeInfo :: Ptr () -> Ptr () -> Ptr (ITypeInfo a) -> Ptr Word32 -> IO Int32
addFuncDesc :: UINT
            -> FUNCDESC
            -> ICreateTypeInfo a0
            -> IO ()
addFuncDesc index pFuncDesc iptr =
  do
    pFuncDesc <- marshallref (allocBytes (fromIntegral sizeofFUNCDESC)) writeFUNCDESC pFuncDesc
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_addFuncDesc methPtr iptr index pFuncDesc) 9 iptr
    free pFuncDesc

foreign import stdcall "dynamic" prim_TypeLib_addFuncDesc :: Ptr () -> Ptr () -> Word32 -> Ptr FUNCDESC -> IO Int32
addImplType :: UINT
            -> HREFTYPE
            -> ICreateTypeInfo a0
            -> IO ()
addImplType index hRefType iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_addImplType methPtr iptr index hRefType)
                 10
                 iptr

foreign import stdcall "dynamic" prim_TypeLib_addImplType :: Ptr () -> Ptr () -> Word32 -> Word32 -> IO Int32
setImplTypeFlags :: UINT
                 -> INT
                 -> ICreateTypeInfo a0
                 -> IO ()
setImplTypeFlags index implTypeFlags iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setImplTypeFlags methPtr iptr index implTypeFlags)
                 11
                 iptr

foreign import stdcall "dynamic" prim_TypeLib_setImplTypeFlags :: Ptr () -> Ptr () -> Word32 -> Int32 -> IO Int32
setAlignment :: WORD
             -> ICreateTypeInfo a0
             -> IO ()
setAlignment cbAlignment0 iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setAlignment methPtr iptr cbAlignment0)
                 12
                 iptr

foreign import stdcall "dynamic" prim_TypeLib_setAlignment :: Ptr () -> Ptr () -> Word16 -> IO Int32
setSchema :: LPOLESTR
          -> ICreateTypeInfo a0
          -> IO ()
setSchema pStrSchema iptr =
  do
    pStrSchema <- marshallWideString pStrSchema
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setDocString methPtr iptr pStrSchema) 13 iptr
    freeWideString pStrSchema

addVarDesc :: UINT
           -> VARDESC
           -> ICreateTypeInfo a0
           -> IO ()
addVarDesc index pVarDesc iptr =
  do
    pVarDesc <- marshallref (allocBytes (fromIntegral sizeofVARDESC)) writeVARDESC pVarDesc
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_addVarDesc methPtr iptr index pVarDesc) 14 iptr
    free pVarDesc

foreign import stdcall "dynamic" prim_TypeLib_addVarDesc :: Ptr () -> Ptr () -> Word32 -> Ptr VARDESC -> IO Int32
setFuncAndParamNames :: UINT
                     -> [LPOLESTR]
                     -> ICreateTypeInfo a0
                     -> IO ()
setFuncAndParamNames index rgszNames iptr =
  let
   cNames = (fromIntegral (length rgszNames) :: Word32)
  in
  do
    rgszNames <- marshalllist sizeofPtr writeWideString rgszNames
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setFuncAndParamNames methPtr iptr index rgszNames cNames) 15 iptr
    free rgszNames

foreign import stdcall "dynamic" prim_TypeLib_setFuncAndParamNames :: Ptr () -> Ptr () -> Word32 -> Ptr (Ptr WideString) -> Word32 -> IO Int32
setVarName :: UINT
           -> LPOLESTR
           -> ICreateTypeInfo a0
           -> IO ()
setVarName index szName iptr =
  do
    szName <- marshallWideString szName
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setVarName methPtr iptr index szName) 16 iptr
    freeWideString szName

foreign import stdcall "dynamic" prim_TypeLib_setVarName :: Ptr () -> Ptr () -> Word32 -> Ptr WideString -> IO Int32
setTypeDescAlias :: TYPEDESC
                 -> ICreateTypeInfo a0
                 -> IO ()
setTypeDescAlias pTDescAlias iptr =
  do
    pTDescAlias <- marshallref (allocBytes (fromIntegral sizeofTYPEDESC)) writeTYPEDESC pTDescAlias
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setTypeDescAlias methPtr iptr pTDescAlias) 17 iptr
    free pTDescAlias

foreign import stdcall "dynamic" prim_TypeLib_setTypeDescAlias :: Ptr () -> Ptr () -> Ptr TYPEDESC -> IO Int32
defineFuncAsDllEntry :: UINT
                     -> LPOLESTR
                     -> LPOLESTR
                     -> ICreateTypeInfo a0
                     -> IO ()
defineFuncAsDllEntry index szDllName szProcName iptr =
  do
    szDllName <- marshallWideString szDllName
    szProcName <- marshallWideString szProcName
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_defineFuncAsDllEntry methPtr iptr index szDllName szProcName) 18 iptr
    freeWideString szDllName
    freeWideString szProcName

foreign import stdcall "dynamic" prim_TypeLib_defineFuncAsDllEntry :: Ptr () -> Ptr () -> Word32 -> Ptr WideString -> Ptr WideString -> IO Int32
setFuncDocString :: UINT
                 -> LPOLESTR
                 -> ICreateTypeInfo a0
                 -> IO ()
setFuncDocString index szDocString iptr =
  do
    szDocString <- marshallWideString szDocString
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setVarName methPtr iptr index szDocString) 19 iptr
    freeWideString szDocString

setVarDocString :: UINT
                -> LPOLESTR
                -> ICreateTypeInfo a0
                -> IO ()
setVarDocString index szDocString iptr =
  do
    szDocString <- marshallWideString szDocString
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setVarName methPtr iptr index szDocString) 20 iptr
    freeWideString szDocString

setFuncHelpContext :: UINT
                   -> DWORD
                   -> ICreateTypeInfo a0
                   -> IO ()
setFuncHelpContext index dwHelpContext0 iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_addImplType methPtr iptr index dwHelpContext0)
                 21
                 iptr

setVarHelpContext :: UINT
                  -> DWORD
                  -> ICreateTypeInfo a0
                  -> IO ()
setVarHelpContext index dwHelpContext0 iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_addImplType methPtr iptr index dwHelpContext0)
                 22
                 iptr

setMops :: UINT
        -> String
        -> ICreateTypeInfo a0
        -> IO ()
setMops index bstrMops iptr =
  do
    bstrMops <- marshallBSTR bstrMops
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setMops methPtr iptr index bstrMops) 23 iptr
    freeBSTR bstrMops

foreign import stdcall "dynamic" prim_TypeLib_setMops :: Ptr () -> Ptr () -> Word32 -> Ptr String -> IO Int32
setTypeIdldesc :: IDLDESC
               -> ICreateTypeInfo a0
               -> IO ()
setTypeIdldesc pIdlDesc iptr =
  do
    pIdlDesc <- marshallref (allocBytes (fromIntegral sizeofIDLDESC)) writeIDLDESC pIdlDesc
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setTypeIdldesc methPtr iptr pIdlDesc) 24 iptr
    free pIdlDesc

foreign import stdcall "dynamic" prim_TypeLib_setTypeIdldesc :: Ptr () -> Ptr () -> Ptr IDLDESC -> IO Int32
layOut :: ICreateTypeInfo a0
       -> IO ()
layOut iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_layOut methPtr iptr)
                 25
                 iptr

foreign import stdcall "dynamic" prim_TypeLib_layOut :: Ptr () -> Ptr () -> IO Int32
-- --------------------------------------------------
-- 
-- interface ICreateTypeInfo2
-- 
-- --------------------------------------------------
data ICreateTypeInfo2_ a = ICreateTypeInfo2__
                             
type ICreateTypeInfo2 a = ICreateTypeInfo (ICreateTypeInfo2_ a)
iidICreateTypeInfo2 :: IID (ICreateTypeInfo2 ())
iidICreateTypeInfo2 =
  mkIID "{0002040E-0000-0000-C000-000000000046}"

type LPCREATETYPEINFO2 = Maybe (ICreateTypeInfo2 ())
deleteFuncDesc :: UINT
               -> ICreateTypeInfo2 a0
               -> IO ()
deleteFuncDesc index iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setTypeFlags methPtr iptr index)
                 26
                 iptr

deleteFuncDescByMemId :: MEMBERID
                      -> INVOKEKIND
                      -> ICreateTypeInfo2 a0
                      -> IO ()
deleteFuncDescByMemId memid1 invKind iptr =
  do
    invKind <- marshallEnum32 invKind
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_deleteFuncDescByMemId methPtr iptr memid1 invKind) 27 iptr

foreign import stdcall "dynamic" prim_TypeLib_deleteFuncDescByMemId :: Ptr () -> Ptr () -> Int32 -> Int32 -> IO Int32
deleteVarDesc :: UINT
              -> ICreateTypeInfo2 a0
              -> IO ()
deleteVarDesc index iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setTypeFlags methPtr iptr index)
                 28
                 iptr

deleteVarDescByMemId :: MEMBERID
                     -> ICreateTypeInfo2 a0
                     -> IO ()
deleteVarDescByMemId memid1 iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_deleteVarDescByMemId methPtr iptr memid1)
                 29
                 iptr

foreign import stdcall "dynamic" prim_TypeLib_deleteVarDescByMemId :: Ptr () -> Ptr () -> Int32 -> IO Int32
deleteImplType :: UINT
               -> ICreateTypeInfo2 a0
               -> IO ()
deleteImplType index iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setTypeFlags methPtr iptr index)
                 30
                 iptr

setCustData :: REFGUID
            -> VARIANT
            -> ICreateTypeInfo2 a0
            -> IO ()
setCustData guid1 pVarVal iptr =
  do
    guid1 <- marshallGUID guid1
    pVarVal <- marshallVARIANT pVarVal
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid1 (\ guid1 -> prim_TypeLib_setCustData methPtr iptr guid1 pVarVal)) 31 iptr
    free pVarVal

foreign import stdcall "dynamic" prim_TypeLib_setCustData :: Ptr () -> Ptr () -> Ptr GUID -> VARIANT -> IO Int32
setFuncCustData :: UINT
                -> REFGUID
                -> VARIANT
                -> ICreateTypeInfo2 a0
                -> IO ()
setFuncCustData index guid1 pVarVal iptr =
  do
    guid1 <- marshallGUID guid1
    pVarVal <- marshallVARIANT pVarVal
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid1 (\ guid1 -> prim_TypeLib_setFuncCustData methPtr iptr index guid1 pVarVal)) 32 iptr
    free pVarVal

foreign import stdcall "dynamic" prim_TypeLib_setFuncCustData :: Ptr () -> Ptr () -> Word32 -> Ptr GUID -> VARIANT -> IO Int32
setParamCustData :: UINT
                 -> UINT
                 -> REFGUID
                 -> VARIANT
                 -> ICreateTypeInfo2 a0
                 -> IO ()
setParamCustData indexFunc indexParam guid1 pVarVal iptr =
  do
    guid1 <- marshallGUID guid1
    pVarVal <- marshallVARIANT pVarVal
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid1 (\ guid1 -> prim_TypeLib_setParamCustData methPtr iptr indexFunc indexParam guid1 pVarVal)) 33 iptr
    free pVarVal

foreign import stdcall "dynamic" prim_TypeLib_setParamCustData :: Ptr () -> Ptr () -> Word32 -> Word32 -> Ptr GUID -> VARIANT -> IO Int32
setVarCustData :: UINT
               -> REFGUID
               -> VARIANT
               -> ICreateTypeInfo2 a0
               -> IO ()
setVarCustData index guid1 pVarVal iptr =
  do
    guid1 <- marshallGUID guid1
    pVarVal <- marshallVARIANT pVarVal
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid1 (\ guid1 -> prim_TypeLib_setFuncCustData methPtr iptr index guid1 pVarVal)) 34 iptr
    free pVarVal

setImplTypeCustData :: UINT
                    -> REFGUID
                    -> VARIANT
                    -> ICreateTypeInfo2 a0
                    -> IO ()
setImplTypeCustData index guid1 pVarVal iptr =
  do
    guid1 <- marshallGUID guid1
    pVarVal <- marshallVARIANT pVarVal
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid1 (\ guid1 -> prim_TypeLib_setFuncCustData methPtr iptr index guid1 pVarVal)) 35 iptr
    free pVarVal

setHelpStringContext :: ULONG
                     -> ICreateTypeInfo2 a0
                     -> IO ()
setHelpStringContext dwHelpStringContext iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setTypeFlags methPtr iptr dwHelpStringContext)
                 36
                 iptr

setFuncHelpStringContext :: UINT
                         -> ULONG
                         -> ICreateTypeInfo2 a0
                         -> IO ()
setFuncHelpStringContext index dwHelpStringContext iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_addImplType methPtr iptr index dwHelpStringContext)
                 37
                 iptr

setVarHelpStringContext :: UINT
                        -> ULONG
                        -> ICreateTypeInfo2 a0
                        -> IO ()
setVarHelpStringContext index dwHelpStringContext iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_addImplType methPtr iptr index dwHelpStringContext)
                 38
                 iptr

invalidate :: ICreateTypeInfo2 a0
           -> IO ()
invalidate iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_layOut methPtr iptr)
                 39
                 iptr

setName :: LPOLESTR
        -> ICreateTypeInfo2 a0
        -> IO ()
setName szName iptr =
  do
    szName <- marshallWideString szName
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setDocString methPtr iptr szName) 40 iptr
    freeWideString szName

-- --------------------------------------------------
-- 
-- interface ICreateTypeLib
-- 
-- --------------------------------------------------
data ICreateTypeLib_ a = ICreateTypeLib__
                           
type ICreateTypeLib a = IUnknown (ICreateTypeLib_ a)
iidICreateTypeLib :: IID (ICreateTypeLib ())
iidICreateTypeLib = mkIID "{00020406-0000-0000-C000-000000000046}"

type LPCREATETYPELIB = Maybe (ICreateTypeLib ())
createTypeInfo :: LPOLESTR
               -> TYPEKIND
               -> ICreateTypeLib a0
               -> IO (ICreateTypeInfo ())
createTypeInfo szName tkind iptr =
  do
    ppCTInfo <- allocBytes (fromIntegral sizeofForeignPtr)
    szName <- marshallWideString szName
    tkind <- marshallEnum32 tkind
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_createTypeInfo methPtr iptr szName tkind ppCTInfo) 3 iptr
    freeWideString szName
    doThenFree free (readIUnknown False) ppCTInfo

foreign import stdcall "dynamic" prim_TypeLib_createTypeInfo :: Ptr () -> Ptr () -> Ptr WideString -> Int32 -> Ptr (Ptr (ICreateTypeInfo a)) -> IO Int32
setNameCTL :: LPOLESTR
           -> ICreateTypeLib a0
           -> IO ()
setNameCTL szName iptr =
  do
    szName <- marshallWideString szName
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setDocString methPtr iptr szName) 4 iptr
    freeWideString szName

setVersionCTL :: WORD
              -> WORD
              -> ICreateTypeLib a0
              -> IO ()
setVersionCTL wMajorVerNum0 wMinorVerNum0 iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setVersion methPtr iptr wMajorVerNum0 wMinorVerNum0)
                 5
                 iptr

setGuidCTL :: REFGUID
           -> ICreateTypeLib a0
           -> IO ()
setGuidCTL guid1 iptr =
  do
    guid1 <- marshallGUID guid1
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid1 (\ guid1 -> prim_TypeLib_setGuid methPtr iptr guid1)) 6 iptr

setDocStringCTL :: LPOLESTR
                -> ICreateTypeLib a0
                -> IO ()
setDocStringCTL szDoc iptr =
  do
    szDoc <- marshallWideString szDoc
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setDocString methPtr iptr szDoc) 7 iptr
    freeWideString szDoc

setHelpFileName :: LPOLESTR
                -> ICreateTypeLib a0
                -> IO ()
setHelpFileName szHelpFileName iptr =
  do
    szHelpFileName <- marshallWideString szHelpFileName
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setDocString methPtr iptr szHelpFileName) 8 iptr
    freeWideString szHelpFileName

setHelpContextCTL :: DWORD
                  -> ICreateTypeLib a0
                  -> IO ()
setHelpContextCTL dwHelpContext0 iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setTypeFlags methPtr iptr dwHelpContext0)
                 9
                 iptr

setLcid :: LCID
        -> ICreateTypeLib a0
        -> IO ()
setLcid lcid0 iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setTypeFlags methPtr iptr lcid0)
                 10
                 iptr

setLibFlags :: UINT
            -> ICreateTypeLib a0
            -> IO ()
setLibFlags uLibFlags iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setTypeFlags methPtr iptr uLibFlags)
                 11
                 iptr

saveAllChanges :: ICreateTypeLib a0
               -> IO ()
saveAllChanges iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_layOut methPtr iptr)
                 12
                 iptr

-- --------------------------------------------------
-- 
-- interface ICreateTypeLib2
-- 
-- --------------------------------------------------
data ICreateTypeLib2_ a = ICreateTypeLib2__
                            
type ICreateTypeLib2 a = ICreateTypeLib (ICreateTypeLib2_ a)
iidICreateTypeLib2 :: IID (ICreateTypeLib2 ())
iidICreateTypeLib2 = mkIID "{0002040F-0000-0000-C000-000000000046}"

type LPCREATETYPELIB2 = Maybe (ICreateTypeLib2 ())
deleteTypeInfo :: LPOLESTR
               -> ICreateTypeLib2 a0
               -> IO ()
deleteTypeInfo szName iptr =
  do
    szName <- marshallWideString szName
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setDocString methPtr iptr szName) 13 iptr
    freeWideString szName

setCustDataCTL :: REFGUID
               -> VARIANT
               -> ICreateTypeLib2 a0
               -> IO ()
setCustDataCTL guid1 pVarVal iptr =
  do
    guid1 <- marshallGUID guid1
    pVarVal <- marshallVARIANT pVarVal
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid1 (\ guid1 -> prim_TypeLib_setCustData methPtr iptr guid1 pVarVal)) 14 iptr
    free pVarVal

setHelpStringContextCTL :: ULONG
                        -> ICreateTypeLib2 a0
                        -> IO ()
setHelpStringContextCTL dwHelpStringContext iptr =
  invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setTypeFlags methPtr iptr dwHelpStringContext)
                 15
                 iptr

setHelpStringDll :: LPOLESTR
                 -> ICreateTypeLib2 a0
                 -> IO ()
setHelpStringDll szFileName iptr =
  do
    szFileName <- marshallWideString szFileName
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_setDocString methPtr iptr szFileName) 16 iptr
    freeWideString szFileName

{- BEGIN_C_CODE
/* DISPID reserved to indicate an "unknown" name */
END_C_CODE-}
{- BEGIN_C_CODE
/* only reserved for data members (properties); reused as a method dispid below */
END_C_CODE-}
dISPID_UNKNOWN :: DISPID
dISPID_UNKNOWN = (negate 1)

{- BEGIN_C_CODE
/* DISPID reserved for the "value" property */
END_C_CODE-}
dISPID_VALUE :: DISPID
dISPID_VALUE = 0

{- BEGIN_C_CODE
/* The following DISPID is reserved to indicate the param
END_C_CODE-}
{- BEGIN_C_CODE
 * that is the right-hand-side (or "put" value) of a PropertyPut
END_C_CODE-}
{- BEGIN_C_CODE
 */
END_C_CODE-}
dISPID_PROPERTYPUT :: DISPID
dISPID_PROPERTYPUT = (negate 3)

{- BEGIN_C_CODE
/* DISPID reserved for the standard "NewEnum" method */
END_C_CODE-}
dISPID_NEWENUM :: DISPID
dISPID_NEWENUM = (negate 4)

{- BEGIN_C_CODE
/* DISPID reserved for the standard "Evaluate" method */
END_C_CODE-}
dISPID_EVALUATE :: DISPID
dISPID_EVALUATE = (negate 5)

dISPID_CONSTRUCTOR :: DISPID
dISPID_CONSTRUCTOR = (negate 6)

dISPID_DESTRUCTOR :: DISPID
dISPID_DESTRUCTOR = (negate 7)

dISPID_COLLECT :: DISPID
dISPID_COLLECT = (negate 8)

-- --------------------------------------------------
-- 
-- interface ITypeComp
-- 
-- --------------------------------------------------
data ITypeComp_ a = ITypeComp__
                      
type ITypeComp a = IUnknown (ITypeComp_ a)
iidITypeComp :: IID (ITypeComp ())
iidITypeComp = mkIID "{00020403-0000-0000-C000-000000000046}"

type LPTYPECOMP = Maybe (ITypeComp ())
data DESCKIND
 = DESCKIND_NONE
 | DESCKIND_FUNCDESC
 | DESCKIND_VARDESC
 | DESCKIND_TYPECOMP
 | DESCKIND_IMPLICITAPPOBJ
 | DESCKIND_MAX
 deriving (Enum)
data BINDPTR
 = Lpfuncdesc (Maybe FUNCDESC)
 | Lpvardesc (Maybe VARDESC)
 | Lptcomp (ITypeComp ())
 
marshallBINDPTR :: BINDPTR
                -> IO (BINDPTR, Int32)
marshallBINDPTR = marshallUnion "marshallBINDPTR"

unmarshallBINDPTR :: BINDPTR
                  -> Int32
                  -> IO BINDPTR
unmarshallBINDPTR = unmarshallUnion "unmarshallBINDPTR"

writeBINDPTR :: Bool
             -> (Int32 -> IO ())
             -> Ptr BINDPTR
             -> BINDPTR
             -> IO ()
writeBINDPTR addRefMe__ write_tag ptr v =
  case v of
     (Lpfuncdesc lpfuncdesc) -> do
                                  write_tag (-1)
                                  writeunique (allocBytes (fromIntegral sizeofFUNCDESC)) writeFUNCDESC (castPtr ptr) lpfuncdesc
     (Lpvardesc lpvardesc) -> do
                                write_tag (-1)
                                writeunique (allocBytes (fromIntegral sizeofVARDESC)) writeVARDESC (castPtr ptr) lpvardesc
     (Lptcomp lptcomp) -> do
                            write_tag (-1)
                            writeIUnknown addRefMe__ (castPtr ptr) lptcomp

readBINDPTR :: Bool
            -> IO Int32
            -> Ptr BINDPTR
            -> IO BINDPTR
readBINDPTR finaliseMe__ read_tag ptr =
  error "readBINDPTR: I am the walrus."

sizeofBINDPTR :: Word32
sizeofBINDPTR = 4

freeBINDPTR :: Int32
            -> Ptr BINDPTR
            -> IO ()
freeBINDPTR read_tag ptr = error "freeBINDPTR: I am the walrus."

type LPBINDPTR = BINDPTR
bind :: LPOLESTR
     -> ULONG
     -> WORD
     -> ITypeComp a0
     -> IO (ITypeInfo (), DESCKIND, BINDPTR)
bind szName lHashVal wFlags iptr =
  do
    ppTInfo <- allocBytes (fromIntegral sizeofForeignPtr)
    pDescKind <- allocBytes (fromIntegral sizeofInt32)
    pBindPtr <- allocBytes (fromIntegral sizeofBINDPTR)
    szName <- marshallWideString szName
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_bind methPtr iptr szName lHashVal wFlags ppTInfo pDescKind pBindPtr) 3 iptr
    freeWideString szName
    ppTInfo <- doThenFree free (readIUnknown False) ppTInfo
    pDescKind <- doThenFree free readEnum32 pDescKind
    pBindPtr <- doThenFree free (readBINDPTR False (return ((-1)))) pBindPtr
    return (ppTInfo, pDescKind, pBindPtr)

foreign import stdcall "dynamic" prim_TypeLib_bind :: Ptr () -> Ptr () -> Ptr WideString -> Word32 -> Word16 -> Ptr (Ptr (ITypeInfo a)) -> Ptr DESCKIND -> Ptr BINDPTR -> IO Int32
bindType :: LPOLESTR
         -> ULONG
         -> ITypeComp a0
         -> IO (ITypeInfo (), ITypeComp ())
bindType szName lHashVal iptr =
  do
    ppTInfo <- allocBytes (fromIntegral sizeofForeignPtr)
    ppTComp <- allocBytes (fromIntegral sizeofForeignPtr)
    szName <- marshallWideString szName
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_bindType methPtr iptr szName lHashVal ppTInfo ppTComp) 4 iptr
    freeWideString szName
    ppTInfo <- doThenFree free (readIUnknown False) ppTInfo
    ppTComp <- doThenFree free (readIUnknown False) ppTComp
    return (ppTInfo, ppTComp)

foreign import stdcall "dynamic" prim_TypeLib_bindType :: Ptr () -> Ptr () -> Ptr WideString -> Word32 -> Ptr (Ptr (ITypeInfo a)) -> Ptr (Ptr (ITypeComp a)) -> IO Int32
-- --------------------------------------------------
-- 
-- interface ITypeInfo
-- 
-- --------------------------------------------------
data ITypeInfo_ a = ITypeInfo__
                      
type ITypeInfo a = IUnknown (ITypeInfo_ a)
iidITypeInfo :: IID (ITypeInfo ())
iidITypeInfo = mkIID "{00020401-0000-0000-C000-000000000046}"

type LPTYPEINFO = Maybe (ITypeInfo ())
getTypeAttr :: ITypeInfo a0
            -> IO (Maybe TYPEATTR)
getTypeAttr iptr =
  do
    ppTypeAttr <- allocBytes (fromIntegral sizeofPtr)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getTypeAttr methPtr iptr ppTypeAttr) 3 iptr
    doThenFree free (readunique (readTYPEATTR False)) ppTypeAttr

foreign import stdcall "dynamic" prim_TypeLib_getTypeAttr :: Ptr () -> Ptr () -> Ptr (Ptr TYPEATTR) -> IO Int32
getTypeComp :: ITypeInfo a0
            -> IO (ITypeComp ())
getTypeComp iptr =
  do
    ppTComp <- allocBytes (fromIntegral sizeofForeignPtr)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getTypeComp methPtr iptr ppTComp) 4 iptr
    doThenFree free (readIUnknown False) ppTComp

foreign import stdcall "dynamic" prim_TypeLib_getTypeComp :: Ptr () -> Ptr () -> Ptr (Ptr (ITypeComp a)) -> IO Int32
getFuncDesc :: UINT
            -> ITypeInfo a0
            -> IO (Maybe FUNCDESC)
getFuncDesc index iptr =
  do
    ppFuncDesc <- allocBytes (fromIntegral sizeofPtr)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getFuncDesc methPtr iptr index ppFuncDesc) 5 iptr
    doThenFree free (readunique readFUNCDESC) ppFuncDesc

foreign import stdcall "dynamic" prim_TypeLib_getFuncDesc :: Ptr () -> Ptr () -> Word32 -> Ptr (Ptr FUNCDESC) -> IO Int32
getVarDesc :: UINT
           -> ITypeInfo a0
           -> IO (Maybe VARDESC)
getVarDesc index iptr =
  do
    ppVarDesc <- allocBytes (fromIntegral sizeofPtr)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getVarDesc methPtr iptr index ppVarDesc) 6 iptr
    doThenFree free (readunique readVARDESC) ppVarDesc

foreign import stdcall "dynamic" prim_TypeLib_getVarDesc :: Ptr () -> Ptr () -> Word32 -> Ptr (Ptr VARDESC) -> IO Int32
getNames :: MEMBERID
         -> UINT
         -> ITypeInfo a0
         -> IO [String]
getNames memid1 cMaxNames iptr =
  do
    rgBstrNames <- allocBytes ((fromIntegral sizeofPtr * fromIntegral cMaxNames))
    pcNames <- allocBytes (fromIntegral sizeofWord32)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getNames methPtr iptr memid1 rgBstrNames cMaxNames pcNames) 7 iptr
    cMaxNames <- unmarshallWord32 cMaxNames
    pcNames <- readWord32 pcNames
    let pcNames' = (pcNames)
    doThenFree free (unmarshalllist sizeofPtr 0 ((fromIntegral ((pcNames')) :: Word32)) readBSTR) rgBstrNames

foreign import stdcall "dynamic" prim_TypeLib_getNames :: Ptr () -> Ptr () -> Int32 -> Ptr String -> Word32 -> Ptr Word32 -> IO Int32
getRefTypeOfImplType :: UINT
                     -> ITypeInfo a0
                     -> IO HREFTYPE
getRefTypeOfImplType index iptr =
  do
    pRefType <- allocBytes (fromIntegral sizeofWord32)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getRefTypeOfImplType methPtr iptr index pRefType) 8 iptr
    doThenFree free readWord32 pRefType

foreign import stdcall "dynamic" prim_TypeLib_getRefTypeOfImplType :: Ptr () -> Ptr () -> Word32 -> Ptr Word32 -> IO Int32
getImplTypeFlags :: UINT
                 -> ITypeInfo a0
                 -> IO INT
getImplTypeFlags index iptr =
  do
    pImplTypeFlags <- allocBytes (fromIntegral sizeofInt32)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getImplTypeFlags methPtr iptr index pImplTypeFlags) 9 iptr
    doThenFree free readInt32 pImplTypeFlags

foreign import stdcall "dynamic" prim_TypeLib_getImplTypeFlags :: Ptr () -> Ptr () -> Word32 -> Ptr Int32 -> IO Int32
getIDsOfNames :: [LPOLESTR]
              -> ITypeInfo a0
              -> IO [MEMBERID]
getIDsOfNames rgszNames iptr =
  let
   cNames = (fromIntegral (length rgszNames) :: Word32)
  in
  do
    rgszNames <- marshalllist sizeofPtr writeWideString rgszNames
    pMemId <- allocBytes ((fromIntegral sizeofInt32 * fromIntegral cNames))
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getIDsOfNames methPtr iptr rgszNames cNames pMemId) 10 iptr
    free rgszNames
    cNames <- unmarshallWord32 cNames
    doThenFree (freeref trivialFree) (unmarshalllist sizeofInt32 0 ((fromIntegral cNames :: Word32)) readInt32) pMemId

foreign import stdcall "dynamic" prim_TypeLib_getIDsOfNames :: Ptr () -> Ptr () -> Ptr (Ptr WideString) -> Word32 -> Ptr Int32 -> IO Int32
invoke :: PVOID
       -> MEMBERID
       -> WORD
       -> DISPPARAMS
       -> ITypeInfo a0
       -> IO (DISPPARAMS, VARIANT, EXCEPINFO, UINT)
invoke pvInstance memid1 wFlags pDispParams iptr =
  do
    pVarResult <- allocVARIANT
    pExcepInfo <- allocBytes (fromIntegral sizeofEXCEPINFO)
    puArgErr <- allocBytes (fromIntegral sizeofWord32)
    pDispParams <- marshallref (allocBytes (fromIntegral sizeofDISPPARAMS)) writeDISPPARAMS pDispParams
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_invoke methPtr iptr pvInstance memid1 wFlags pDispParams pVarResult pExcepInfo puArgErr) 11 iptr
    pVarResult <- unmarshallVARIANT pVarResult
    pExcepInfo <- doThenFree free readEXCEPINFO pExcepInfo
    puArgErr <- doThenFree free readWord32 puArgErr
    pDispParams <- doThenFree free readDISPPARAMS pDispParams
    return (pDispParams, pVarResult, pExcepInfo, puArgErr)

foreign import stdcall "dynamic" prim_TypeLib_invoke :: Ptr () -> Ptr () -> Ptr () -> Int32 -> Word16 -> Ptr DISPPARAMS -> VARIANT -> Ptr EXCEPINFO -> Ptr Word32 -> IO Int32
getDocumentation :: MEMBERID
                 -> ITypeInfo a0
                 -> IO (String, String, DWORD, String)
getDocumentation memid1 iptr =
  do
    pBstrName <- allocBytes (fromIntegral sizeofPtr)
    pBstrDocString <- allocBytes (fromIntegral sizeofPtr)
    pdwHelpContext <- allocBytes (fromIntegral sizeofWord32)
    pBstrHelpFile <- allocBytes (fromIntegral sizeofPtr)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getDocumentation methPtr iptr memid1 pBstrName pBstrDocString pdwHelpContext pBstrHelpFile) 12 iptr
    pBstrName <- doThenFree (freeref freeBSTR) readBSTR pBstrName
    pBstrDocString <- doThenFree (freeref freeBSTR) readBSTR pBstrDocString
    pdwHelpContext <- doThenFree free readWord32 pdwHelpContext
    pBstrHelpFile <- doThenFree (freeref freeBSTR) readBSTR pBstrHelpFile
    return (pBstrName, pBstrDocString, pdwHelpContext, pBstrHelpFile)

foreign import stdcall "dynamic" prim_TypeLib_getDocumentation :: Ptr () -> Ptr () -> Int32 -> Ptr String -> Ptr String -> Ptr Word32 -> Ptr String -> IO Int32
getDllEntry :: MEMBERID
            -> INVOKEKIND
            -> ITypeInfo a0
            -> IO (String, String, WORD)
getDllEntry memid1 invKind iptr =
  do
    pBstrDllName <- allocBytes (fromIntegral sizeofPtr)
    pBstrName <- allocBytes (fromIntegral sizeofPtr)
    pwOrdinal <- allocBytes (fromIntegral sizeofWord16)
    invKind <- marshallEnum32 invKind
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getDllEntry methPtr iptr memid1 invKind pBstrDllName pBstrName pwOrdinal) 13 iptr
    pBstrDllName <- doThenFree (freeref freeBSTR) readBSTR pBstrDllName
    pBstrName <- doThenFree (freeref freeBSTR) readBSTR pBstrName
    pwOrdinal <- doThenFree free readWord16 pwOrdinal
    return (pBstrDllName, pBstrName, pwOrdinal)

foreign import stdcall "dynamic" prim_TypeLib_getDllEntry :: Ptr () -> Ptr () -> Int32 -> Int32 -> Ptr String -> Ptr String -> Ptr Word16 -> IO Int32
getRefTypeInfo :: HREFTYPE
               -> ITypeInfo a0
               -> IO (ITypeInfo ())
getRefTypeInfo hRefType iptr =
  do
    ppTInfo <- allocBytes (fromIntegral sizeofForeignPtr)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getRefTypeInfo methPtr iptr hRefType ppTInfo) 14 iptr
    doThenFree free (readIUnknown False) ppTInfo

foreign import stdcall "dynamic" prim_TypeLib_getRefTypeInfo :: Ptr () -> Ptr () -> Word32 -> Ptr (Ptr (ITypeInfo a)) -> IO Int32
addressOfMember :: MEMBERID
                -> INVOKEKIND
                -> ITypeInfo a0
                -> IO PVOID
addressOfMember memid1 invKind iptr =
  do
    ppv <- allocBytes (fromIntegral sizeofPtr)
    invKind <- marshallEnum32 invKind
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_addressOfMember methPtr iptr memid1 invKind ppv) 15 iptr
    doThenFree free readPtr ppv

foreign import stdcall "dynamic" prim_TypeLib_addressOfMember :: Ptr () -> Ptr () -> Int32 -> Int32 -> Ptr (Ptr ()) -> IO Int32
createInstance :: IUnknown a2
               -> IID a3
               -> ITypeInfo a0
               -> IO (IUnknown a1)
createInstance pUnkOuter riid iptr =
  do
    ppvObj <- allocBytes (fromIntegral sizeofForeignPtr)
    pUnkOuter <- marshallIUnknown pUnkOuter
    riid <- marshallIID riid
    invokeAndCheck (\ methPtr iptr -> withForeignPtr pUnkOuter (\ pUnkOuter -> withForeignPtr riid (\ riid -> prim_TypeLib_createInstance methPtr iptr pUnkOuter riid ppvObj))) 16 iptr
    doThenFree free (readIUnknown False) ppvObj

foreign import stdcall "dynamic" prim_TypeLib_createInstance :: Ptr () -> Ptr () -> Ptr (IUnknown a) -> Ptr (IID a) -> Ptr (Ptr (IUnknown a)) -> IO Int32
getMops :: MEMBERID
        -> ITypeInfo a0
        -> IO String
getMops memid1 iptr =
  do
    pBstrMops <- allocBytes (fromIntegral sizeofPtr)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getMops methPtr iptr memid1 pBstrMops) 17 iptr
    doThenFree (freeref freeBSTR) readBSTR pBstrMops

foreign import stdcall "dynamic" prim_TypeLib_getMops :: Ptr () -> Ptr () -> Int32 -> Ptr String -> IO Int32
getContainingTypeLib :: ITypeInfo a0
                     -> IO (ITypeLib (), UINT)
getContainingTypeLib iptr =
  do
    ppTLib <- allocBytes (fromIntegral sizeofForeignPtr)
    pIndex <- allocBytes (fromIntegral sizeofWord32)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getContainingTypeLib methPtr iptr ppTLib pIndex) 18 iptr
    ppTLib <- doThenFree free (readIUnknown False) ppTLib
    pIndex <- doThenFree free readWord32 pIndex
    return (ppTLib, pIndex)

foreign import stdcall "dynamic" prim_TypeLib_getContainingTypeLib :: Ptr () -> Ptr () -> Ptr (Ptr (ITypeLib a)) -> Ptr Word32 -> IO Int32
releaseTypeAttr :: Ptr TYPEATTR
                -> ITypeInfo a0
                -> IO ()
releaseTypeAttr pTypeAttr iptr =
  invokeIt (\ methPtr iptr -> prim_TypeLib_releaseTypeAttr methPtr iptr pTypeAttr)
           19
           iptr

foreign import stdcall "dynamic" prim_TypeLib_releaseTypeAttr :: Ptr () -> Ptr () -> Ptr TYPEATTR -> IO ()
releaseFuncDesc :: Ptr FUNCDESC
                -> ITypeInfo a0
                -> IO ()
releaseFuncDesc pFuncDesc iptr =
  invokeIt (\ methPtr iptr -> prim_TypeLib_releaseFuncDesc methPtr iptr pFuncDesc)
           20
           iptr

foreign import stdcall "dynamic" prim_TypeLib_releaseFuncDesc :: Ptr () -> Ptr () -> Ptr FUNCDESC -> IO ()
releaseVarDesc :: Ptr VARDESC
               -> ITypeInfo a0
               -> IO ()
releaseVarDesc pVarDesc iptr =
  invokeIt (\ methPtr iptr -> prim_TypeLib_releaseVarDesc methPtr iptr pVarDesc)
           21
           iptr

foreign import stdcall "dynamic" prim_TypeLib_releaseVarDesc :: Ptr () -> Ptr () -> Ptr VARDESC -> IO ()
-- --------------------------------------------------
-- 
-- interface ITypeInfo2
-- 
-- --------------------------------------------------
data ITypeInfo2_ a = ITypeInfo2__
                       
type ITypeInfo2 a = ITypeInfo (ITypeInfo2_ a)
iidITypeInfo2 :: IID (ITypeInfo2 ())
iidITypeInfo2 = mkIID "{00020412-0000-0000-C000-000000000046}"

type LPTYPEINFO2 = Maybe (ITypeInfo2 ())
getTypeKind :: ITypeInfo2 a0
            -> IO TYPEKIND
getTypeKind iptr =
  do
    pTypeKind <- allocBytes (fromIntegral sizeofInt32)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getTypeKind methPtr iptr pTypeKind) 22 iptr
    doThenFree free readEnum32 pTypeKind

foreign import stdcall "dynamic" prim_TypeLib_getTypeKind :: Ptr () -> Ptr () -> Ptr TYPEKIND -> IO Int32
getTypeFlags :: ITypeInfo2 a0
             -> IO ULONG
getTypeFlags iptr =
  do
    pTypeFlags <- allocBytes (fromIntegral sizeofWord32)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getTypeFlags methPtr iptr pTypeFlags) 23 iptr
    doThenFree free readWord32 pTypeFlags

foreign import stdcall "dynamic" prim_TypeLib_getTypeFlags :: Ptr () -> Ptr () -> Ptr Word32 -> IO Int32
getFuncIndexOfMemId :: MEMBERID
                    -> INVOKEKIND
                    -> ITypeInfo2 a0
                    -> IO UINT
getFuncIndexOfMemId memid1 invKind iptr =
  do
    pFuncIndex <- allocBytes (fromIntegral sizeofWord32)
    invKind <- marshallEnum32 invKind
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getFuncIndexOfMemId methPtr iptr memid1 invKind pFuncIndex) 24 iptr
    doThenFree free readWord32 pFuncIndex

foreign import stdcall "dynamic" prim_TypeLib_getFuncIndexOfMemId :: Ptr () -> Ptr () -> Int32 -> Int32 -> Ptr Word32 -> IO Int32
getVarIndexOfMemId :: MEMBERID
                   -> ITypeInfo2 a0
                   -> IO UINT
getVarIndexOfMemId memid1 iptr =
  do
    pVarIndex <- allocBytes (fromIntegral sizeofWord32)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getVarIndexOfMemId methPtr iptr memid1 pVarIndex) 25 iptr
    doThenFree free readWord32 pVarIndex

foreign import stdcall "dynamic" prim_TypeLib_getVarIndexOfMemId :: Ptr () -> Ptr () -> Int32 -> Ptr Word32 -> IO Int32
getCustData :: REFGUID
            -> ITypeInfo2 a0
            -> IO VARIANT
getCustData guid1 iptr =
  do
    pVarVal <- allocVARIANT
    guid1 <- marshallGUID guid1
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid1 (\ guid1 -> prim_TypeLib_setCustData methPtr iptr guid1 pVarVal)) 26 iptr
    unmarshallVARIANT pVarVal

getFuncCustData :: UINT
                -> REFGUID
                -> ITypeInfo2 a0
                -> IO VARIANT
getFuncCustData index guid1 iptr =
  do
    pVarVal <- allocVARIANT
    guid1 <- marshallGUID guid1
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid1 (\ guid1 -> prim_TypeLib_setFuncCustData methPtr iptr index guid1 pVarVal)) 27 iptr
    unmarshallVARIANT pVarVal

getParamCustData :: UINT
                 -> UINT
                 -> REFGUID
                 -> ITypeInfo2 a0
                 -> IO VARIANT
getParamCustData indexFunc indexParam guid1 iptr =
  do
    pVarVal <- allocVARIANT
    guid1 <- marshallGUID guid1
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid1 (\ guid1 -> prim_TypeLib_setParamCustData methPtr iptr indexFunc indexParam guid1 pVarVal)) 28 iptr
    unmarshallVARIANT pVarVal

getVarCustData :: UINT
               -> REFGUID
               -> ITypeInfo2 a0
               -> IO VARIANT
getVarCustData index guid1 iptr =
  do
    pVarVal <- allocVARIANT
    guid1 <- marshallGUID guid1
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid1 (\ guid1 -> prim_TypeLib_setFuncCustData methPtr iptr index guid1 pVarVal)) 29 iptr
    unmarshallVARIANT pVarVal

getImplTypeCustData :: UINT
                    -> REFGUID
                    -> ITypeInfo2 a0
                    -> IO VARIANT
getImplTypeCustData index guid1 iptr =
  do
    pVarVal <- allocVARIANT
    guid1 <- marshallGUID guid1
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid1 (\ guid1 -> prim_TypeLib_setFuncCustData methPtr iptr index guid1 pVarVal)) 30 iptr
    unmarshallVARIANT pVarVal

getDocumentation2 :: MEMBERID
                  -> LCID
                  -> ITypeInfo2 a0
                  -> IO (String, DWORD, String)
getDocumentation2 memid1 lcid0 iptr =
  do
    pbstrHelpString <- allocBytes (fromIntegral sizeofPtr)
    pdwHelpStringContext <- allocBytes (fromIntegral sizeofWord32)
    pbstrHelpStringDll <- allocBytes (fromIntegral sizeofPtr)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getDocumentation2 methPtr iptr memid1 lcid0 pbstrHelpString pdwHelpStringContext pbstrHelpStringDll) 31 iptr
    pbstrHelpString <- doThenFree (freeref freeBSTR) readBSTR pbstrHelpString
    pdwHelpStringContext <- doThenFree free readWord32 pdwHelpStringContext
    pbstrHelpStringDll <- doThenFree (freeref freeBSTR) readBSTR pbstrHelpStringDll
    return (pbstrHelpString, pdwHelpStringContext, pbstrHelpStringDll)

foreign import stdcall "dynamic" prim_TypeLib_getDocumentation2 :: Ptr () -> Ptr () -> Int32 -> Word32 -> Ptr String -> Ptr Word32 -> Ptr String -> IO Int32
getAllCustData :: ITypeInfo2 a0
               -> IO CUSTDATA
getAllCustData iptr =
  do
    pCustData <- allocBytes (fromIntegral sizeofCUSTDATA)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getAllCustData methPtr iptr pCustData) 32 iptr
    doThenFree free (readCUSTDATA False) pCustData

foreign import stdcall "dynamic" prim_TypeLib_getAllCustData :: Ptr () -> Ptr () -> Ptr CUSTDATA -> IO Int32
getAllFuncCustData :: UINT
                   -> ITypeInfo2 a0
                   -> IO CUSTDATA
getAllFuncCustData index iptr =
  do
    pCustData <- allocBytes (fromIntegral sizeofCUSTDATA)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getAllFuncCustData methPtr iptr index pCustData) 33 iptr
    doThenFree free (readCUSTDATA False) pCustData

foreign import stdcall "dynamic" prim_TypeLib_getAllFuncCustData :: Ptr () -> Ptr () -> Word32 -> Ptr CUSTDATA -> IO Int32
getAllParamCustData :: UINT
                    -> UINT
                    -> ITypeInfo2 a0
                    -> IO CUSTDATA
getAllParamCustData indexFunc indexParam iptr =
  do
    pCustData <- allocBytes (fromIntegral sizeofCUSTDATA)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getAllParamCustData methPtr iptr indexFunc indexParam pCustData) 34 iptr
    doThenFree free (readCUSTDATA False) pCustData

foreign import stdcall "dynamic" prim_TypeLib_getAllParamCustData :: Ptr () -> Ptr () -> Word32 -> Word32 -> Ptr CUSTDATA -> IO Int32
getAllVarCustData :: UINT
                  -> ITypeInfo2 a0
                  -> IO CUSTDATA
getAllVarCustData index iptr =
  do
    pCustData <- allocBytes (fromIntegral sizeofCUSTDATA)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getAllFuncCustData methPtr iptr index pCustData) 35 iptr
    doThenFree free (readCUSTDATA False) pCustData

getAllImplTypeCustData :: UINT
                       -> ITypeInfo2 a0
                       -> IO CUSTDATA
getAllImplTypeCustData index iptr =
  do
    pCustData <- allocBytes (fromIntegral sizeofCUSTDATA)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getAllFuncCustData methPtr iptr index pCustData) 36 iptr
    doThenFree free (readCUSTDATA False) pCustData

-- --------------------------------------------------
-- 
-- interface ITypeLib
-- 
-- --------------------------------------------------
data ITypeLib_ a = ITypeLib__
                     
type ITypeLib a = IUnknown (ITypeLib_ a)
iidITypeLib :: IID (ITypeLib ())
iidITypeLib = mkIID "{00020402-0000-0000-C000-000000000046}"

data SYSKIND
 = SYSKINDList__ [SYSKIND]
 | SYS_WIN16
 | SYS_WIN32
 | SYS_MAC
 
instance Flags (SYSKIND) where
  x1 .+. x2
    = toEnum ((fromEnum x1 + fromEnum x2))
  
instance Enum (SYSKIND) where
  fromEnum v =
    case v of
       (SYSKINDList__ xs) -> orList (map fromEnum xs)
       SYS_WIN16 -> 0
       SYS_WIN32 -> 1
       SYS_MAC -> 2
  
  toEnum v =
    case v of
       0 -> SYS_WIN16
       1 -> SYS_WIN32
       2 -> SYS_MAC
       x -> SYSKINDList__ (mapMaybe (\ val -> if ((val .&. fromIntegral x) == val)
                                                then Just (toEnum (fromIntegral val))
                                                else Nothing) (pow2Series 3 0))
       _ -> error "unmarshallSYSKIND: illegal enum value "
  
data LIBFLAGS
 = LIBFLAGSList__ [LIBFLAGS]
 | LIBFLAG_FRESTRICTED
 | LIBFLAG_FCONTROL
 | LIBFLAG_FHIDDEN
 | LIBFLAG_FHASDISKIMAGE
 
instance Flags (LIBFLAGS) where
  x1 .+. x2
    = toEnum ((fromEnum x1 + fromEnum x2))
  
instance Enum (LIBFLAGS) where
  fromEnum v =
    case v of
       (LIBFLAGSList__ xs) -> orList (map fromEnum xs)
       LIBFLAG_FRESTRICTED -> 1
       LIBFLAG_FCONTROL -> 2
       LIBFLAG_FHIDDEN -> 4
       LIBFLAG_FHASDISKIMAGE -> 8
  
  toEnum v =
    case v of
       1 -> LIBFLAG_FRESTRICTED
       2 -> LIBFLAG_FCONTROL
       4 -> LIBFLAG_FHIDDEN
       8 -> LIBFLAG_FHASDISKIMAGE
       x -> LIBFLAGSList__ (mapMaybe (\ val -> if ((val .&. fromIntegral x) == val)
                                                 then Just (toEnum (fromIntegral val))
                                                 else Nothing) (pow2Series 4 1))
       _ -> error "unmarshallLIBFLAGS: illegal enum value "
  
type LPTYPELIB = Maybe (ITypeLib ())
data TLIBATTR = TagTLIBATTR {guid1 :: GUID,
                             lcid0 :: LCID,
                             syskind :: SYSKIND,
                             wMajorVerNum0 :: WORD,
                             wMinorVerNum0 :: WORD,
                             wLibFlags :: WORD}
                  
writeTLIBATTR :: Ptr TLIBATTR
              -> TLIBATTR
              -> IO ()
writeTLIBATTR ptr (TagTLIBATTR guid1 lcid0 syskind wMajorVerNum0 wMinorVerNum0 wLibFlags) =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    writeGUID pf1 guid1
    let pf2 = addNCastPtr pf1 16
    writeWord32 pf2 lcid0
    let pf3 = addNCastPtr pf2 4
    writeEnum32 pf3 syskind
    let pf4 = addNCastPtr pf3 4
    writeWord16 pf4 wMajorVerNum0
    let pf5 = addNCastPtr pf4 2
    writeWord16 pf5 wMinorVerNum0
    let pf6 = addNCastPtr pf5 2
    writeWord16 pf6 wLibFlags

readTLIBATTR :: Bool
             -> Ptr TLIBATTR
             -> IO TLIBATTR
readTLIBATTR finaliseMe__ ptr =
  let
   pf0 = ptr
   pf1 = addNCastPtr pf0 0
  in
  do
    guid1 <- readGUID finaliseMe__ pf1
    let pf2 = addNCastPtr pf1 16
    lcid0 <- readWord32 pf2
    let pf3 = addNCastPtr pf2 4
    syskind <- readEnum32 pf3
    let pf4 = addNCastPtr pf3 4
    wMajorVerNum0 <- readWord16 pf4
    let pf5 = addNCastPtr pf4 2
    wMinorVerNum0 <- readWord16 pf5
    let pf6 = addNCastPtr pf5 2
    wLibFlags <- readWord16 pf6
    return (TagTLIBATTR guid1 lcid0 syskind wMajorVerNum0 wMinorVerNum0 wLibFlags)

sizeofTLIBATTR :: Word32
sizeofTLIBATTR = 32

type LPTLIBATTR = TLIBATTR
getTypeInfoCount :: ITypeLib a0
                 -> IO UINT
getTypeInfoCount iptr =
  invokeIt (\ methPtr iptr -> prim_TypeLib_getTypeInfoCount methPtr iptr)
           3
           iptr

foreign import stdcall "dynamic" prim_TypeLib_getTypeInfoCount :: Ptr () -> Ptr () -> IO Word32
getTypeInfo :: UINT
            -> ITypeLib a0
            -> IO (ITypeInfo ())
getTypeInfo index iptr =
  do
    ppTInfo <- allocBytes (fromIntegral sizeofForeignPtr)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getRefTypeInfo methPtr iptr index ppTInfo) 4 iptr
    doThenFree free (readIUnknown False) ppTInfo

getTypeInfoType :: UINT
                -> ITypeLib a0
                -> IO TYPEKIND
getTypeInfoType index iptr =
  do
    pTKind <- allocBytes (fromIntegral sizeofInt32)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getTypeInfoType methPtr iptr index pTKind) 5 iptr
    doThenFree free readEnum32 pTKind

foreign import stdcall "dynamic" prim_TypeLib_getTypeInfoType :: Ptr () -> Ptr () -> Word32 -> Ptr TYPEKIND -> IO Int32
getTypeInfoOfGuid :: REFGUID
                  -> ITypeLib a0
                  -> IO (ITypeInfo ())
getTypeInfoOfGuid guid2 iptr =
  do
    ppTinfo <- allocBytes (fromIntegral sizeofForeignPtr)
    guid2 <- marshallGUID guid2
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid2 (\ guid2 -> prim_TypeLib_getTypeInfoOfGuid methPtr iptr guid2 ppTinfo)) 6 iptr
    doThenFree free (readIUnknown False) ppTinfo

foreign import stdcall "dynamic" prim_TypeLib_getTypeInfoOfGuid :: Ptr () -> Ptr () -> Ptr GUID -> Ptr (Ptr (ITypeInfo a)) -> IO Int32
getLibAttr :: ITypeLib a0
           -> IO (Maybe TLIBATTR)
getLibAttr iptr =
  do
    ppTLibAttr <- allocBytes (fromIntegral sizeofPtr)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getLibAttr methPtr iptr ppTLibAttr) 7 iptr
    doThenFree free (readunique (readTLIBATTR False)) ppTLibAttr

foreign import stdcall "dynamic" prim_TypeLib_getLibAttr :: Ptr () -> Ptr () -> Ptr (Ptr TLIBATTR) -> IO Int32
getTypeCompTL :: ITypeLib a0
              -> IO (ITypeComp ())
getTypeCompTL iptr =
  do
    ppTComp <- allocBytes (fromIntegral sizeofForeignPtr)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getTypeComp methPtr iptr ppTComp) 8 iptr
    doThenFree free (readIUnknown False) ppTComp

getDocumentationTL :: INT
                   -> ITypeLib a0
                   -> IO (String, String, DWORD, String)
getDocumentationTL index iptr =
  do
    pBstrName <- allocBytes (fromIntegral sizeofPtr)
    pBstrDocString <- allocBytes (fromIntegral sizeofPtr)
    pdwHelpContext <- allocBytes (fromIntegral sizeofWord32)
    pBstrHelpFile <- allocBytes (fromIntegral sizeofPtr)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getDocumentation methPtr iptr index pBstrName pBstrDocString pdwHelpContext pBstrHelpFile) 9 iptr
    pBstrName <- doThenFree (freeref freeBSTR) readBSTR pBstrName
    pBstrDocString <- doThenFree (freeref freeBSTR) readBSTR pBstrDocString
    pdwHelpContext <- doThenFree free readWord32 pdwHelpContext
    pBstrHelpFile <- doThenFree (freeref freeBSTR) readBSTR pBstrHelpFile
    return (pBstrName, pBstrDocString, pdwHelpContext, pBstrHelpFile)

isName :: LPOLESTR
       -> ULONG
       -> ITypeLib a0
       -> IO (LPOLESTR, BOOL)
isName szNameBuf lHashVal iptr =
  do
    pfName <- allocBytes (fromIntegral sizeofInt32)
    szNameBuf <- marshallWideString szNameBuf
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_isName methPtr iptr szNameBuf lHashVal pfName) 10 iptr
    pfName <- doThenFree free readInt32 pfName
    szNameBuf <- doThenFree freeWideString unmarshallWideString szNameBuf
    return (szNameBuf, pfName)

foreign import stdcall "dynamic" prim_TypeLib_isName :: Ptr () -> Ptr () -> Ptr WideString -> Word32 -> Ptr Int32 -> IO Int32
findName :: LPOLESTR
         -> ULONG
         -> USHORT
         -> ITypeLib a0
         -> IO (LPOLESTR, [ITypeInfo ()], [MEMBERID])
findName szNameBuf lHashVal pcFound iptr =
  do
    ppTInfo <- allocBytes ((fromIntegral sizeofForeignPtr * fromIntegral ((pcFound))))
    rgMemId <- allocBytes ((fromIntegral sizeofInt32 * fromIntegral ((pcFound))))
    szNameBuf <- marshallWideString szNameBuf
    pcFound <- marshallref (allocBytes (fromIntegral sizeofWord16)) writeWord16 pcFound
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_findName methPtr iptr szNameBuf lHashVal ppTInfo rgMemId pcFound) 11 iptr
    szNameBuf <- doThenFree freeWideString unmarshallWideString szNameBuf
    pcFound <- readWord16 pcFound
    let pcFound' = (pcFound)
    ppTInfo <- doThenFree (freeref trivialFree) (unmarshalllist sizeofForeignPtr 0 ((fromIntegral ((pcFound')) :: Word32)) (readIUnknown False)) ppTInfo
    rgMemId <- doThenFree (freeref trivialFree) (unmarshalllist sizeofInt32 0 ((fromIntegral ((pcFound')) :: Word32)) readInt32) rgMemId
    return (szNameBuf, ppTInfo, rgMemId)

foreign import stdcall "dynamic" prim_TypeLib_findName :: Ptr () -> Ptr () -> Ptr WideString -> Word32 -> Ptr (Ptr (ITypeInfo a)) -> Ptr Int32 -> Ptr Word16 -> IO Int32
releaseTLibAttr :: Ptr TLIBATTR
                -> ITypeLib a0
                -> IO ()
releaseTLibAttr pTLibAttr iptr =
  invokeIt (\ methPtr iptr -> prim_TypeLib_releaseTLibAttr methPtr iptr pTLibAttr)
           12
           iptr

foreign import stdcall "dynamic" prim_TypeLib_releaseTLibAttr :: Ptr () -> Ptr () -> Ptr TLIBATTR -> IO ()
-- --------------------------------------------------
-- 
-- interface ITypeLib2
-- 
-- --------------------------------------------------
data ITypeLib2_ a = ITypeLib2__
                      
type ITypeLib2 a = ITypeLib (ITypeLib2_ a)
iidITypeLib2 :: IID (ITypeLib2 ())
iidITypeLib2 = mkIID "{00020411-0000-0000-C000-000000000046}"

type LPTYPELIB2 = Maybe (ITypeLib2 ())
getCustDataTL :: GUID
              -> ITypeLib2 a0
              -> IO VARIANT
getCustDataTL guid2 iptr =
  do
    pVarVal <- allocVARIANT
    guid2 <- marshallGUID guid2
    invokeAndCheck (\ methPtr iptr -> withForeignPtr guid2 (\ guid2 -> prim_TypeLib_setCustData methPtr iptr guid2 pVarVal)) 13 iptr
    unmarshallVARIANT pVarVal

getLibStatistics :: ITypeLib2 a0
                 -> IO (ULONG, ULONG)
getLibStatistics iptr =
  do
    pcUniqueNames <- allocBytes (fromIntegral sizeofWord32)
    pcchUniqueNames <- allocBytes (fromIntegral sizeofWord32)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getLibStatistics methPtr iptr pcUniqueNames pcchUniqueNames) 14 iptr
    pcUniqueNames <- doThenFree free readWord32 pcUniqueNames
    pcchUniqueNames <- doThenFree free readWord32 pcchUniqueNames
    return (pcUniqueNames, pcchUniqueNames)

foreign import stdcall "dynamic" prim_TypeLib_getLibStatistics :: Ptr () -> Ptr () -> Ptr Word32 -> Ptr Word32 -> IO Int32
getDocumentation2TL :: INT
                    -> LCID
                    -> ITypeLib2 a0
                    -> IO (String, DWORD, String)
getDocumentation2TL index lcid1 iptr =
  do
    pbstrHelpString <- allocBytes (fromIntegral sizeofPtr)
    pdwHelpStringContext <- allocBytes (fromIntegral sizeofWord32)
    pbstrHelpStringDll <- allocBytes (fromIntegral sizeofPtr)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getDocumentation2 methPtr iptr index lcid1 pbstrHelpString pdwHelpStringContext pbstrHelpStringDll) 15 iptr
    pbstrHelpString <- doThenFree (freeref freeBSTR) readBSTR pbstrHelpString
    pdwHelpStringContext <- doThenFree free readWord32 pdwHelpStringContext
    pbstrHelpStringDll <- doThenFree (freeref freeBSTR) readBSTR pbstrHelpStringDll
    return (pbstrHelpString, pdwHelpStringContext, pbstrHelpStringDll)

getAllCustDataTL :: ITypeLib2 a0
                 -> IO CUSTDATA
getAllCustDataTL iptr =
  do
    pCustData <- allocBytes (fromIntegral sizeofCUSTDATA)
    invokeAndCheck (\ methPtr iptr -> prim_TypeLib_getAllCustData methPtr iptr pCustData) 16 iptr
    doThenFree free (readCUSTDATA False) pCustData

-- --------------------------------------------------
-- 
-- interface ITypeChangeEvents
-- 
-- --------------------------------------------------
data ITypeChangeEvents_ a = ITypeChangeEvents__
                              
type ITypeChangeEvents a = IUnknown (ITypeChangeEvents_ a)
iidITypeChangeEvents :: IID (ITypeChangeEvents ())
iidITypeChangeEvents =
  mkIID "{00020410-0000-0000-C000-000000000046}"

type LPTYPECHANGEEVENTS = Maybe (ITypeChangeEvents ())
data CHANGEKIND
 = CHANGEKIND_ADDMEMBER
 | CHANGEKIND_DELETEMEMBER
 | CHANGEKIND_SETNAMES
 | CHANGEKIND_SETDOCUMENTATION
 | CHANGEKIND_GENERAL
 | CHANGEKIND_INVALIDATE
 | CHANGEKIND_CHANGEFAILED
 | CHANGEKIND_MAX
 deriving (Enum)
requestTypeChange :: CHANGEKIND
                  -> ITypeInfo a1
                  -> LPOLESTR
                  -> ITypeChangeEvents a0
                  -> IO INT
requestTypeChange changeKind pTInfoBefore pStrName iptr =
  do
    pfCancel <- allocBytes (fromIntegral sizeofInt32)
    changeKind <- marshallEnum32 changeKind
    pTInfoBefore <- marshallIUnknown pTInfoBefore
    pStrName <- marshallWideString pStrName
    invokeAndCheck (\ methPtr iptr -> withForeignPtr pTInfoBefore (\ pTInfoBefore -> prim_TypeLib_requestTypeChange methPtr iptr changeKind pTInfoBefore pStrName pfCancel)) 3 iptr
    freeWideString pStrName
    doThenFree free readInt32 pfCancel

foreign import stdcall "dynamic" prim_TypeLib_requestTypeChange :: Ptr () -> Ptr () -> Int32 -> Ptr (ITypeInfo a) -> Ptr WideString -> Ptr Int32 -> IO Int32
afterTypeChange :: CHANGEKIND
                -> ITypeInfo a1
                -> LPOLESTR
                -> ITypeChangeEvents a0
                -> IO ()
afterTypeChange changeKind pTInfoAfter pStrName iptr =
  do
    changeKind <- marshallEnum32 changeKind
    pTInfoAfter <- marshallIUnknown pTInfoAfter
    pStrName <- marshallWideString pStrName
    invokeAndCheck (\ methPtr iptr -> withForeignPtr pTInfoAfter (\ pTInfoAfter -> prim_TypeLib_afterTypeChange methPtr iptr changeKind pTInfoAfter pStrName)) 4 iptr
    freeWideString pStrName

foreign import stdcall "dynamic" prim_TypeLib_afterTypeChange :: Ptr () -> Ptr () -> Int32 -> Ptr (ITypeInfo a) -> Ptr WideString -> IO Int32

